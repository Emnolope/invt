<!DOCTYPE html>
<html>
<head>
  <title>Inventory App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
body {
  height: 100vh;
  font-family: system-ui, -apple-system, sans-serif;
  overflow: hidden;
}
.mode {
  display: none;
}
.mode.active {
  display: block;
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  overflow-y: auto;
  overflow-x: hidden;
}
#modeBtn {
  position: fixed;
  top: 10px;
  right: 10px;
  z-index: 1000;
  padding: 10px;
}
#camera {
  width: 100vw;
  height: 100vh;
  object-fit: cover;
  cursor: pointer;
}
/* WHAT IS THIS, either needs renaming or deletion */
.placeholder {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 3em;
  background: #333;
  color: white;
}
#gallery {
  display: grid;
  grid-template-columns: 1fr 1fr;
}
.gallery-item {
  width: 100%;
  aspect-ratio: 1;
  object-fit: cover;
  cursor: pointer;
}
/***** WIZARD STYLING *****/
#wizardOverlay {
  position: fixed;
  display: none;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  flex-direction: column;
  z-index: 2;
  background: #000;
  padding: 2px;
  gap: 2px;
}
.wizardPane {
  flex: 1;
  display: grid;
  gap: 2px;
}
.wizard-screen {
  display: none;
  background: #000;
  gap: 2px;
}
.wizard-screen.active {
  display: grid;
}
#wizardNavi {
  height: 80px;
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 2px;
}
.wizard-input {
  display: none;
}
.wizard-label {
  display: flex;
  align-items: center;
  justify-content: center;
  background: #ddd;
  font-size: 2em;
  cursor: pointer;
  user-select: none;
  border: none;
}
.wizard-label:hover {
  background: #bbb;
}
.wizard-input:checked + .wizard-label {
  background: #007bff;
  color: white;
}
.wizard-input:checked + .wizard-label:hover {
  background: #0056b3;
}
.nav-button {
  font-size: 1.5em;
  background: #333;
  color: white;
  border: none;
  cursor: pointer;
  user-select: none;
  display: flex;
  align-items: center;
  justify-content: center;
}
.nav-button:hover {
  background: #555;
}
.nav-button:active {
  background: #777;
}
.wizard-text {
  width: 100%;
  height: 100%;
  font-size: 2em;
  padding: 20px;
  background: #fff;
  border: none;
  outline: none;
  resize: none;
}
  </style>
</head>
<body>
  <div id="app">
    <div id="mode0" class="mode">
      <video id="camera" autoplay playsinline onclick="inventoryCapture('rapid')"></video>
      <div class="camera-controls">
        <button onclick="cameraTorchButton()">üî¶</button>
        <button onclick="cameraFlipButton()">üîÑ</button>
      </div>
    </div>
    <div id="mode1" class="mode placeholder">SLOW PICTURE MODE</div>
    <div id="mode2" class="mode">
      <div id="gallery"></div>
    </div>
    <div id="mode3" class="mode placeholder">TABLE VIEW</div>
    <div id="mode4" class="mode placeholder">
      <button onclick="fileFolderPickButton()">fileFolderPick</button>
      <button onclick="inventoryLoadButton()">inventoryLoad</button>
      <div>
        <textarea id="schemaTextarea" placeholder="Schema JSON"></textarea>
        <button onclick="schemaLoadButton()">schemaLoad</button>
        <button onclick="schemaLearnButton()">schemaLearn</button>
        <button onclick="schemaSaveButton()">schemaSave</button>
      </div>
      <textarea id="output" readonly style="width: 100%; font-family: monospace; font-size: 12px; overflow-y: auto;"></textarea>
    </div>
  </div>
  <button id="modeBtn" onclick="interfaceNext()"></button>
  <div id="wizardOverlay">
    <div id="wizardPanels" class="wizardPane">
    </div>
    <div id="wizardNavi">
    </div>
  </div>
<script src="https://cdn.jsdelivr.net/npm/eruda"></script>
<script>eruda.init();</script>
  <script>
/***** SYSTEM *****/
function log(...msgs) {
  const message = msgs.map(msg => 
    typeof msg === 'object' ? JSON.stringify(msg, null, 2) : String(msg)
  ).join(' ');
  const outputBox = document.getElementById('output');
  outputBox.value += `[${new Date().toISOString()}] ${message}\n`;
  outputBox.scrollTop = outputBox.scrollHeight;
}
window.onload = async function init() {
  interfaceRender();
  await Camera.init();
}
log('script start');
/***** LOW LEVEL I/O OPERATIONS *****/
let folder;
async function fileCheck(filename) {
  try {
    await folder.getFileHandle(filename);
    return true;
  }
  catch (e) {
    if (e.name === 'NotFoundError') return false;
    throw e;
  }
}
async function fileRead(filename) {
  log(`‚ÜòÔ∏èfileRead`);
  const handle = await folder.getFileHandle(filename);
  return await handle.getFile();
}
async function fileWrite(filename, data, allowOverwrite = false) {
  log(`‚ÜòÔ∏èfileWrite`);
  if (!allowOverwrite && await fileCheck(filename)) {
    throw new Error(`Exists: ${filename}`);
  }
  const handle = await folder.getFileHandle(filename, {create: true});
  const writer = await handle.createWritable();
  await writer.write(data);
  await writer.close();
}
async function fileDelete(filename) {
  log(`‚ÜòÔ∏èfileDelete`);
  await folder.removeEntry(filename);
}
async function fileRename(oldPath, newPath) {
  log(`‚ÜòÔ∏èfileRename`);
  if (await fileCheck(newPath)) {
    throw new Error(`Destination exists: ${newPath}`);
  }
  try {
    const data = await fileRead(oldPath);
    await fileWrite(newPath, data);
  } 
  catch (e) {
    log(`‚ùå fileRename, copy fail: `, ...arguments, e.message);
    throw new Error(`Copy failed: ${e.message}`);
  }
  try {
    await fileDelete(oldPath);
  } 
  catch (e) {
    log(`‚ùå fileRename, delete fail: `, ...arguments, e.message);
    throw new Error(`Rename incomplete: ${newPath} created, ${oldPath} remains`);
  }
}
async function fileListAll() {
  log(`‚ÜòÔ∏èfileListAll`);
  const files = [];
  for await (const [name, handle] of folder.entries()) {
    if (handle.kind === 'file') files.push(name);
  }
  return files;
}
async function fileFind(uuid) {
  log(`‚ÜòÔ∏èfileFind`);
  const reconstructedFilename = metadataToName(inventory[uuid]?.metadata);
  if (reconstructedFilename && await fileCheck(reconstructedFilename)) {
    return reconstructedFilename;
  }
  const candidateFiles = (await fileListAll()).filter(filename => 
    filename.match(`_${uuid}\\.`)
  );
  log(`fileFind: `, candidateFiles);
  if (!candidateFiles.length) return null;
  if (candidateFiles.length === 1) return candidateFiles[0];
  const filesWithTimestamps = await Promise.all(
    candidateFiles.map(async filename => ({
      filename,
      lastModified: (await (await folder.getFileHandle(filename)).getFile()).lastModified
    }))
  );
  return filesWithTimestamps
    .sort((a, b) => b.lastModified - a.lastModified)[0]
    .filename;
}
async function fileFolderPick() {
  log(`‚ÜòÔ∏èfileFolderPick`);
  folder = await window.showDirectoryPicker();
}
async function fileFolderPickButton() {
  try {fileFolderPick();}
  catch (e) {log("fileFolderPickButton: ", e.message);}
}
/***** UUID catalogue *****/
let inventory = {};
async function inventorySave(imageData, metadata) {
  log(`‚ÜòÔ∏èinventorySave`);
  const filename = metadataToName(metadata);
  const response = await fetch(imageData);
  const blob = await response.blob();
  await fileWrite(filename, blob);
  return filename;
}
async function inventoryCapture(rapid=true) {
  log(`‚ÜòÔ∏èinventoryCapture`);
  try {
    if (!Camera.Ok()) {
      await Camera.init();
    }
    const imageData = cameraCapture(Camera);
    const metadata = rapid
      ? await metadataEmpty()
      : {
        data: { UUID: metadataUUID(), ext: "jpg" },
        values: await Wizard.record()
      };
    const filename = await inventorySave(imageData, metadata);
    const uuid = inventoryUpdate(filename, metadata);
    log(`üì∏ ${filename}`);
    return uuid;
  } 
  catch (e) {
    log(`‚ùå inventoryCapture: `, ...arguments, e.message);
    if (!Camera.stream?.active) { Camera.stream = null; }
    return null;
  }
}
function inventoryCaptureButtonFast() {
  log(`‚ÜòÔ∏èinventoryCaptureButtonFast`);
  try {inventoryCapture('rapid');}
  catch(e) {log(e.message);}
}
function inventoryCaptureButtonSlow() {
log(`‚ÜòÔ∏èinventoryCaptureButtonFast`);
  try {inventoryCapture();}
  catch(e) {log(e.message);}
}
// NEEDS CHANGE: Atomic operation, metadata and filename must be in sync.
function inventoryUpdate(filename, metadata) {
  log(`‚ÜòÔ∏èinventoryUpdate`);
  const uuid = metadata.data.UUID;
  inventory[uuid] = { metadata, original: filename };
  return uuid;
}
async function inventoryLoad() {
  log(`‚ÜòÔ∏èinventoryLoad`);
  const filenames = await fileListAll();
  const schema = schemaGet();
  inventory = {};
  for (const filename of filenames) {
    const metadata = metadataFromName(filename, schema);
    if (metadata?.data?.UUID) {
      inventory[metadata.data.UUID] = {
        metadata: metadata,
        original: filename
      };
    }
  }
}
function inventoryLoadButton() {
  log(`‚ÜòÔ∏èinventoryLoadButton`);
  try {inventoryLoad();}
  catch (e) {log(`inventoryLoadButton: `, e.message);}
}
/***** CAMERA *****/
const Camera = {
  stream: null,
  video: null,
  track: null,
  Ok() {
    return this.stream?.active && this.video?.videoWidth > 0;
  },
  async init() {
    log(`‚ÜòÔ∏èCamera.init()`);
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: 'environment' }
        }
      });
      this.video = document.getElementById('camera');
      this.video.srcObject = this.stream;
      this.track = this.stream.getVideoTracks()[0];
      await new Promise((resolve, reject) => {
        // Use once: true to automatically remove the listener after it fires once
        this.video.addEventListener('loadedmetadata', resolve, { once: true });
        setTimeout(() => reject(new Error("Camera stream metadata load timeout.")), 5000); 
      });
    } catch (e) {
      log(`‚ùå Camera.init() failed: `, e.message);
      throw e;
    }
  },
  async flip() {
    log(`‚ÜòÔ∏èCamera.flip()`);
    this.stream?.getTracks().forEach(t => t.stop());
    const currentMode = this.track?.getSettings()?.facingMode;
    const newMode = (currentMode === 'environment') ? 'user' : 'environment';
    this.stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: { ideal: newMode }
      }
    });
    this.video.srcObject = this.stream;
    this.track = this.stream.getVideoTracks()[0];
  },
  async torch() {
    log(`‚ÜòÔ∏èCamera.torch()`);
    if (!this.track) return;
    const currentTorchState = this.track.getSettings().torch || false;
    await this.track.applyConstraints({
      advanced: [{ torch: !currentTorchState }]
    });
  },
  capture() {
    log(`‚ÜòÔ∏èCamera.capture()`);
    if (!this.Ok()) {
      throw new Error("Camera not ready for capture.");
    }
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = this.video.videoWidth;
    canvas.height = this.video.videoHeight;
    ctx.drawImage(this.video, 0, 0);
    return canvas.toDataURL('image/jpeg');
  }
};
function cameraFlipButton() {
  log(`‚ÜòÔ∏ècameraFlipButton`);
  try {Camera.flip();}
  catch(e) {log(`‚ùå cameraFlipButton: `, e.message);}
}
function cameraTorchButton() {
  log(`‚ÜòÔ∏ècameraTorchButton`);
  try {Camera.torch();}
  catch(e) {log(`‚ùå cameraTorchButton: `, e.message);}
}
/***** UI OPERATIONS *****/
const modes = ['üì∏', 'üêå', 'üñºÔ∏è', 'üìä', '‚öôÔ∏è'];
let currentMode = 0;
function interfaceNext() {
  log(`‚ÜòÔ∏èinterfaceNext`);
  currentMode = (currentMode + 1) % modes.length;
  interfaceRender();
  Wizard.kill();
}
function interfaceBack() {
  log(`‚ÜòÔ∏èinterfaceBack`);
  currentMode = (currentMode + modes.length - 1) % modes.length;
  interfaceRender();
  Wizard.kill();
}
function interfaceRender() {
  log(`‚ÜòÔ∏èinterfaceRender`);
  document.querySelectorAll('.mode').forEach(m => m.classList.remove('active'));
  document.getElementById(`mode${currentMode}`).classList.add('active');
  document.getElementById('modeBtn').textContent = modes[currentMode];
  if (currentMode === 2) {
    galleryLoad();
  }
}
/***** DYNAMIC SCHEMA SYSTEM *****/
// RESILIENT PARSING + DEFAULTS: schemaLoad should return default schema structure if all files fail, not empty string. schemaAnalyze should continue processing remaining files when individual metadataFromName calls fail, logging specific problematic filenames. SchemaLearn should never throw - always produce usable schema.
let schemaText = document.getElementById('schemaTextarea');
schemaText.value = '[]';
schemaText.addEventListener('input', ()=>{schemaDirty=true;});
let schemaDirty = false;
const SCHEMANAME = 'schema.json';
// NEEDS CHANGE: Should use fileRead function for consistency. Should not throw - return default schema object if all loads fail.
async function schemaLoad() {
  log(`‚ÜòÔ∏èschemaLoad`);
  try {
    const file = await fileRead(SCHEMANAME);
    const content = await file.text();
    log(`üìÑ Loaded ${SCHEMANAME}`);
    return content;
  } 
  catch (e) {
    log(`‚ùå schemaLoad: `, ...arguments, e.message);
    return '[]';
  }
}
async function schemaLoadButton() {
  log(`‚ÜòÔ∏èschemaLoadButton`);
  try {schemaText.value=await schemaLoad();schemaDirty=false;}
  catch(e) {log(e.message);}
}
async function schemaSave() {
  log(`‚ÜòÔ∏èschemaSave`);
  await fileWrite(SCHEMANAME, schemaText.value, true);
  log(`üíæ Schema saved to ${SCHEMANAME}`);
}
function schemaSaveButton() {
  log(`‚ÜòÔ∏èschemaSaveButton`);
  try {schemaSave(); schemaDirty=false;}
  catch(e) {log(`‚ùå schemaSaveButton: `, ...arguments, e.message);}
}
function schemaMergeOptions(fieldoptions1, fieldoptions2) {
  log(`‚ÜòÔ∏èschemaMergeOptions`);
  const allOptions = [
    ...(fieldoptions1 || []),
    ...(fieldoptions2 || [])
  ];
  const uniqueOptions = allOptions.filter((option, index, self) => self.indexOf(option) === index);
  return uniqueOptions;
}
const schemaHierarchy = { "single": 1, "multiple": 2, "text": 3 };
function schemaFieldUpgrade(currentType, newType) {
  return schemaHierarchy[newType] > schemaHierarchy[currentType] ? newType : currentType;
}
function analyzeFieldPattern(collection) {
  log(`‚ÜòÔ∏èanalyzeFieldPattern`);
  const items = collection.filter(Boolean);
  if (!items.length) {
    return { type: 'single', options: [] };
  }
  let hasText = false;
  let hasMultiple = false;
  const tokens = new Set();
  items.forEach(item => {
    const segments = item.split(',');
    const exceedsThreshold = segments.some(segment => segment.length > 26);
    if (exceedsThreshold) {
      hasText = true;
      tokens.add(item);
    } else if (segments.length > 1) {
      hasMultiple = true;
      segments.forEach(segment => tokens.add(segment));
    } else {
      tokens.add(item);
    }
  });
  const fieldType = hasText ? 'text' : 
                    hasMultiple ? 'multiple' : 
                    'single';
  const result = { type: fieldType };
  if (fieldType !== 'text') {
    result.options = [...tokens];
  }
  return result;
}
// wrap metadataFromName in try catch to keep analysis running even with one bad file
function schemaAnalyze(filenames) {
  log(`‚ÜòÔ∏èschemaAnalyze`);
  const imageFiles = filenames.filter(f => 
    f.toLowerCase().match(/\.(jpg|jpeg|png|gif)$/)
  );
  const allMetadata = imageFiles
    .map(filename => metadataFromName(filename, null))
    .filter(metadata => metadata !== null);
  if (allMetadata.length === 0) return [];
  const maxFields = Math.max(...allMetadata.map(m => m.values.length));
  const fieldCollections = Array.from({ length: maxFields }, () => []);
  allMetadata.forEach(metadata => {
    metadata.values.forEach((valueArray, fieldIndex) => {
      if (valueArray.length > 0 && valueArray[0]) {
        fieldCollections[fieldIndex].push(valueArray[0]);
      }
    });
  });
  return fieldCollections.map((collection, index) => {
    const pattern = analyzeFieldPattern(collection);
    return {
      name: `field${index}`,
      type: pattern.type,
      ...(pattern.type !== 'text' && { options: pattern.options })
    };
  });
}
function schemaFuse(schema1, schema2) {
  log(`‚ÜòÔ∏èschemaFuse`);
  if (!Array.isArray(schema1)) schema1 = [];
  if (!Array.isArray(schema2)) schema2 = [];
  const result = [];
  const maxLength = Math.max(schema1.length, schema2.length);
  for (let i = 0; i < maxLength; i++) {
    const field1 = schema1[i];
    const field2 = schema2[i];
    if (field1 && field2) {
      const mergedOptions = schemaMergeOptions(field1.options, field2.options);
      const finalType = schemaFieldUpgrade(field1.type, field2.type);
      result[i] = {
        name: field1.name || field2.name,
        type: finalType,
        ...(mergedOptions && { options: mergedOptions })
      };
    } else if (field1) {
      result[i] = { ...field1 };
    } else if (field2) {
      result[i] = { ...field2 };
    }
  }
  return result;
}
async function schemaLearn() {
  log(`‚ÜòÔ∏èschemaLearn`);
  const fileList = await fileListAll();
  if (fileList.length === 0) {
    log('‚ÑπÔ∏è No files found for learning');
    return;
  }
  log(`üß† Learning from ${fileList.length} files...`);
  const learnedSchema = schemaAnalyze(fileList);
  const currentSchema = schemaFromText(schemaText.value);
  const fusedSchema = schemaFuse(currentSchema, learnedSchema);
  schemaText.value = schemaToText(fusedSchema);
  schemaDirty = true;
  log('üéì Schema learning complete');
}
function schemaLearnButton() {
  log(`‚ÜòÔ∏èschemaLearnButton`);
  try {schemaLearn(); schemaDirty=true;}
  catch(e) {log(`‚ùå schemaLearnButton`, ...arguments, e.message);}
}
async function schemaInit() {
  log(`‚ÜòÔ∏èschemaInit`);
  schemaText.value = await schemaLoad();
  schemaDirty = false;
  await schemaLearn();
}
function schemaFromText(text) {
  log(`‚ÜòÔ∏èschemaFromText`);
  try {
    if (text == null) throw new Error(`Bit nothin`);
    const parsed = JSON.parse(text);
    return Array.isArray(parsed) ? parsed : []; // ensure array
  } 
  catch (e) {
    log(`‚ùå schemaFromText:`, ...arguments, e.message);
    return [];
  }
}
function schemaToText(schema) {
  log(`‚ÜòÔ∏èschemaToText`);
  try {
    if (schema == null) throw new Error(`Bit nothin`);
    return JSON.stringify(schema, null, 2);
  } 
  catch (e) {
    log("‚ùåschemaToText:", ...arguments, e.message);
    return '';
  }
}
function schemaGet() {
  log(`‚ÜòÔ∏èschemaGet`);
  return schemaFromText(schemaText.value);
}
//<button onclick="schemaValidate()?log('‚úÖ Schema is valid'):log('‚ùå Schema validation failed');">Learn</button>
/***** FILENAME OPERATIONS *****/
function metadataUUID() {
  log(`‚ÜòÔ∏èmetadataUUID`);
  const now = new Date();
  const year = now.getFullYear();                             //4
  const month = String(now.getMonth() + 1).padStart(2, '0');  //2
  const day = String(now.getDate()).padStart(2, '0');         //2
  const hour = String(now.getHours()).padStart(2, '0');       //2
  const min = String(now.getMinutes()).padStart(2, '0');      //2
  const sec = String(now.getSeconds()).padStart(2, '0');      //2
  const mil = String(now.getMilliseconds()).padStart(3, '0'); //3
  return `${year}${month}${day}${hour}${min}${sec}${mil}`;    //4+2+2+2+2+2+3 = 17
}
function metadataFromName(filename, schema=schemaGet()) {
  log(`‚ÜòÔ∏èmetadataFromName`);
  try {
    const parts = filename.split('_');
    const [uuid, ext] = parts.pop().split('.');
    if (!/^\d{17}$/.test(uuid)) {
      throw new Error("Bad UUID!");
    }
    const values = parts.map((part, index) => {
      // Default fallback handles full/incomplete/invalid schema
      if (schema?.[index]?.type === 'multiple') {
        return part.split(',');
      } else {  // 'single', 'text', or unknown/inferred
        return [part];
      }
    });
    return {
      data: { UUID: uuid, ext: ext },
      values: values
    };
  }
  catch (e) {
    log(`‚ùå metadataFromName: `, ...arguments, e.message);
    return null;
  }
}
// AI SLOP: NEEDS CHANGE: Should never fail - return minimal metadata with single empty field if schema loading fails
function metadataToName(metadata) {
  log(`‚ÜòÔ∏èmetadataToName`);
  const parts = metadata.values.map(valueArray => valueArray.join(','));
  return [...parts, metadata.data.UUID].join('_') + '.' + metadata.data.ext;
}
// Does this function even need to hold the same size? Leave values as empty array?
async function metadataEmpty() {
  log(`‚ÜòÔ∏èmetadataEmpty`);
  try {
    const schema = schemaGet();
    const values = Array(schema.length).fill([]);
    return {
      data: {
        UUID: metadataUUID(),
        ext: ""
      },
      values: values
    };
  } 
  catch (e) {
    log(`‚ùå metadataEmpty: `, ...arguments, e.message);
  }
}
/***** GALLERY *****/
let thumbnailCache = {};
const CACHENAME = 'cache.json';
async function galleryLoad() {
  log(`‚ÜòÔ∏ègalleryLoad`);
  try {
    const gallery = document.getElementById('gallery');
    gallery.innerHTML = '';
    await cacheLoad();
    for (const uuid in inventory) {
      await new Promise(resolve => requestAnimationFrame(resolve));
      if (currentMode !== 2) return;
      const thumbnailDataURL = await galleryThumbnailGet(uuid);
      if (thumbnailDataURL) {
        const galleryImg = galleryImageElementCreate(uuid, thumbnailDataURL);
        gallery.appendChild(galleryImg);
      }
    }
    await cacheSave();
  } 
  catch (e) {
    log(`‚ùå galleryLoad: `, ...arguments, e.message);
  }
}
// prevent single image failure from breaking entire gallery
async function cacheLoad() {
  log(`‚ÜòÔ∏ècacheLoad`);
  try {
    const cacheFile = await fileRead(CACHENAME);
    const cacheText = await cacheFile.text();
    const cacheData = JSON.parse(cacheText);
    for (const uuid in cacheData) {
      if (inventory[uuid]) {
        inventory[uuid].thumbnail = cacheData[uuid].thumbnail;
      }
    }
    return cacheData;
  } 
  catch (e) {
    log(`‚ùå cacheLoad: `, ...arguments, e.message);
    return {};
  }
}
async function cacheSave() {
  log(`‚ÜòÔ∏ècameraSave`);
  try {
    const cacheData = {};
    for (const uuid in inventory) {
      if (inventory[uuid].thumbnail) {
        cacheData[uuid] = {
          thumbnail: inventory[uuid].thumbnail
        };
      }
    }
    const cacheJSON = JSON.stringify(cacheData);
    const blob = new Blob([cacheJSON], {type: 'application/json'});
    await fileWrite(CACHENAME, blob);
  } 
  catch (e) {
    log(`‚ùå cacheSave: `, ...arguments, e.message);
  }
}
// no error handling, let error fly
async function galleryThumbnailGet(uuid) {
  log(`‚ÜòÔ∏ègalleryThumbnailGet`);
  if (inventory[uuid] && inventory[uuid].thumbnail) {
    return inventory[uuid].thumbnail; //use existing thumbnail
  }
  const filename = await fileFind(uuid);
  if (!filename) {
    log(`galleryThumbnailGet: ${uuid}`);
    return null;
  }
  const file = await fileRead(filename);
  const thumbnailDataURL = await galleryThumbnailCreate(file);
  if (!inventory[uuid]) {
    inventory[uuid] = {};
  }
  inventory[uuid].thumbnail = thumbnailDataURL;
  return thumbnailDataURL;
}
async function galleryThumbnailCreate(file) {
  log(`‚ÜòÔ∏ègalleryThumbnailCreate`);
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const img = new Image();
  const imgUrl = URL.createObjectURL(file);
  return new Promise((resolve) => {
    img.onload = () => {
      URL.revokeObjectURL(imgUrl);
      const size = 512;
      canvas.width = size;
      canvas.height = size;
      ctx.drawImage(img, 0, 0, size, size);
      const dataURL = canvas.toDataURL('image/jpeg', 0.8);
      resolve(dataURL);
    };
    img.src = imgUrl;
  });
}
function galleryImageElementCreate(uuid, thumbnailDataURL) {
  log(`‚ÜòÔ∏ègalleryImageElementCreate`);
  const galleryImg = document.createElement('img');
  galleryImg.src = thumbnailDataURL;
  galleryImg.className = 'gallery-item';
  galleryImg.loading = 'lazy';
  galleryImg.onclick = async () => {
    const filename = await fileFind(uuid);
    if (!filename) {
      log(`galleryImageElementCreate: ${uuid}`);
      return;
    }
    const file = await fileRead(filename);
    const originalUrl = URL.createObjectURL(file);
    const popup = window.open('', '_blank');
    popup.document.write(`<img src="${originalUrl}" style="max-width:100%;max-height:100%;">`);
  };
  return galleryImg;
}
// DISCUSSION: How to make components more robust?
// RESILIENT INPUT + NON-BLOCKING: Wizard failures return empty metadata rather than throwing. Input validation warns but doesn't prevent progression. Build functions handle missing schema gracefully.
/***** WIZARD OVERLAY *****/
const Wizard = (function() {
  let wizardOverlay;
  let wizardPanels;
  let navi;
  let schema;
  let values;
  let step;
  let resolve;
  let reject;
  function gridSizer(buttonCount, aspectRatio) {
    log(`‚ÜòÔ∏èWizard.gridSizer`);
    let bestRows = 1;
    let bestCols = buttonCount;
    let bestSkinny = 0.0;
    for (let rows = 1; rows <= buttonCount; rows++) {
      const cols = Math.ceil(buttonCount / rows);
      const width = aspectRatio / cols;
      const height = 1.0 / rows;
      const nowSkinny = Math.min(width, height);
      if (nowSkinny > bestSkinny) {
        bestSkinny = nowSkinny;
        bestRows = rows;
        bestCols = cols;
      }
    }
    return { rows: bestRows, cols: bestCols };
  }
  function refresh() {
    log(`‚ÜòÔ∏èWizard.refresh`);
    if (step < 0) {
      step = 0;
    } else if (step >= schema.length) {
      done();
      return;
    }
    const screens = Array.from(wizardPanels.children);
    screens.forEach((screen, index) => {
      if (index === step) {
        screen.classList.add('active');
      } else {
        screen.classList.remove('active');
      }
    });
  }
  function init() {
    log(`‚ÜòÔ∏èWizard.init`);
    wizardOverlay = document.getElementById('wizardOverlay');
    wizardPanels = document.getElementById('wizardPanels');
    wizardPanels.innerHTML = '';
    navi = document.getElementById('wizardNavi');
    navi.innerHTML = '';
    [
      {textContent: '‚¨ÖÔ∏è', onclick: back},
      {textContent: '‚ùå', onclick: kill},
      {textContent: 'üíæ', onclick: done},
      {textContent: '‚û°Ô∏è', onclick: next}
    ].forEach(config => {
      const button = document.createElement('button');
      Object.assign(button, config, { className: 'nav-button' });
      navi.appendChild(button);
    });
  }
  function build() {
    log(`‚ÜòÔ∏èWizard.build`);
    schema.forEach((_, index) => {
      const screen = document.createElement('div');
      screen.className = 'wizard-screen';
      buildScreenContent(screen, index);
      wizardPanels.appendChild(screen);
    });
  }
  // CHANGE?
  function buildScreenContent(screen, index) {
    log(`‚ÜòÔ∏èWizard.buildScreenContent`);
    const field = schema[index];
    if (field.type === 'text') {
      screen.style.cssText = 'grid-template-columns:1fr;grid-template-rows:1fr';
      const textarea = document.createElement('textarea');
      textarea.className = 'wizard-text';
      textarea.placeholder = `Enter ${field.name}`;
      textarea.value = values[index] ? values[index][0] : '';
      textarea.oninput = () => {
        values[index] = [textarea.value];
      };
      screen.appendChild(textarea);
    } else {
      const availableHeight = window.innerHeight - 80;
      const availableWidth = window.innerWidth;
      log(availableHeight);
      log(availableWidth);
      const grid = gridSizer(field.options.length, availableWidth/availableHeight);
      screen.style.cssText = `grid-template-columns:repeat(${grid.cols},1fr);grid-template-rows:repeat(${grid.rows},1fr)`;
      field.options.forEach((option, optionIndex) => {
        const input = document.createElement('input');
        input.value = option;
        input.className = 'wizard-input';
        input.name = `field-${index}`;
        const id = `field-${index}-${field.name}-${optionIndex}`;
        input.id = id;
        if (field.type === 'multiple') {
          input.type = 'checkbox';
          //if (values[index] && values[index].includes(option)) {input.checked = true;}
          input.onchange = () => {
            const checkedInputs = screen.querySelectorAll('input[type="checkbox"]:checked');
            values[index] = Array.from(checkedInputs).map(inp => inp.value);
          };
        } else if (field.type === 'single') {
          input.type = 'radio';
          //if (values[index] && values[index][0] === option) {input.checked = true;}
          input.onchange = () => {
            values[index] = [option];
            next();
          };
        }
        const label = document.createElement('label');
        label.htmlFor = id;
        label.className = 'wizard-label';
        label.textContent = option;
        screen.appendChild(input);
        screen.appendChild(label);
      });
    }
  }
  function mergeMetadata(metadata1, metadata2) {
    log(`‚ÜòÔ∏èmergeMetadata`);
    const mergedResult = { ...metadata1 , ...metadata2 };
    mergedResult.data = {...metadata1.data, ...metadata2.data};
    const isEmptyArray = x => Array.isArray(x) && x.length === 0;
    const maxLength = Math.max(metadata1.values?.length ?? 0, metadata2.values?.length ?? 0)
    mergedResult.values = Array.from({ length: maxLength }, (_, i) =>
      isEmptyArray(metadata2?.values[i]||[]) ?
        (isEmptyArray(metadata1?.values[i]||[]) ?
          []
          :
         metadata1.values[i])
        :
        metadata2.values[i]
    );
    return mergedResult;
  }
  function record() {
    log(`‚ÜòÔ∏èWizard.record`);
    values = [];
    step = 0;
    schema = schemaGet();
    init();
    build();
    wizardOverlay.style.display = 'flex';
    return new Promise((res, rej) => {
      resolve = res;
      reject = rej;
      refresh();
    });
  }
  // DISCUSSION: If the wizard fails for some reason, should it return an empty metadata? Should the calling function save the image with empty metadata?
  function kill() {
    log(`‚ÜòÔ∏èWizard.kill`);
    wizardOverlay.style.display = 'none';
    if (reject) {
      reject(new Error('WIZARD_KILLED'));
    }
  }
  function done() {
    log(`‚ÜòÔ∏èWizard.done`);
    wizardOverlay.style.display = 'none';
    if (resolve) {
      resolve(values);
    }
  }
  function back() {
    log(`‚ÜòÔ∏èWizard.back`);
    step--;
    refresh();
  }
  function next() {
    log(`‚ÜòÔ∏èWizard.next`);
    step++;
    refresh();
  }
  return { record, kill, done, back, next };
})();
log('script end');
  </script>
</body>
</html>
