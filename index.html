<!DOCTYPE html>
<html>
<head>
  <title>InvtSysShell3+ v18.11+</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
/***** RESET *****/
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
/***** LAYOUT *****/
body {
  height: 100vh;
  font-family: system-ui, -apple-system, sans-serif;
  overflow: hidden;
}
/***** UNIVERSAL BUTTON *****/
button {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2em;
  padding: 10px;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  user-select: none;
  background: rgba(0, 0, 0, 0.5);
  color: white;
}
button:hover {
  background: rgba(0, 0, 0, 0.7);
}
button:active {
  background: rgba(0, 0, 0, 0.9);
}
/***** FIXED CONTROLS *****/
.fixed-controls {
  position: fixed;
  display: flex;
  gap: 10px;
  z-index: 100;
}
.mode-controls {
  top: 20px;
  left: 20px;
  right: 20px;
  z-index: 1000;
  justify-content: space-between;
}
.camera-controls {
  bottom: 20px;
  left: 20px;
  right: 20px;
  z-index: 1000;
  justify-content: space-between;
}
/***** MODE SYSTEM *****/
.mode {
  display: none;
}
.mode.active {
  display: block;
  position: fixed;
  inset: 0;
  overflow-y: auto;
  overflow-x: auto;
  padding-top: 80px;
}
/***** CAMERA *****/
#camera {
  width: 100vw;
  height: 100vh;
  object-fit: cover;
  cursor: pointer;
}
/***** GALLERY *****/
#gallery {
  display: grid;
  grid-template-columns: 1fr 1fr;
}
.gallery-item {
  width: 100%;
  aspect-ratio: 1;
  object-fit: cover;
  cursor: pointer;
}
/***** TABLE GRID *****/
#GridHeader, .Row {
  display: grid;
  grid-template-columns: 40px repeat(auto-fit, minmax(140px, 1fr));
  width: fit-content;
  min-width: 626px;
}
#GridHeader {
  font-weight: bold;
  background: #ccc;
  position: sticky;
  top: 0;
  z-index: 10;
}
.Cell {
  overflow: hidden;
  white-space: nowrap;
  user-select: none;
  touch-action: manipulation;
}
.ThumbCell {
  text-align: center;
}
.Thumb {
  width: 100%;
  height: 14px;
  background: #666;
  color: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
}
.Selected {
  background: #8cf;
} 
.Editing {
  background: #ff8;
}
#mode-table input {
  width: 98%;
  box-sizing: border-box;
  font: inherit;
  padding: 0;
  border: 1px solid #000;
}
.table-controls {
  display: flex;
  justify-content: center;
  gap: 10px;
  padding: 10px 0;
  margin-top: 10px;
  width: 626px;
}
.table-controls button {
  font-size: 1em;
  padding: 5px 10px;
  border-radius: 4px;
}
/***** WIZARD OVERLAY *****/
#wizardOverlay {
  position: fixed;
  inset: 0;
  display: none;
  flex-direction: column;
  background: #000;
  padding: 2px;
  gap: 2px;
  z-index: 2000;
}
.wizardPane {
  flex: 1;
  display: grid;
  gap: 2px;
}
.wizard-screen {
  display: none;
  background: #000;
  gap: 2px;
}
.wizard-screen.active {
  display: grid;
}
#wizardNavi {
  height: 80px;
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 2px;
}
#wizardNavi button {
  font-size: 1.5em;
  background: #333;
}
#wizardNavi button:hover {
  background: #555;
}
#wizardNavi button:active {
  background: #777;
}
/***** WIZARD INPUTS *****/
.wizard-input {
  display: none;
}
.wizard-label {
  background: #ddd;
  color: #000;
}
.wizard-label:hover {
  background: #bbb;
}
.wizard-input:checked + .wizard-label {
  background: #007bff;
  color: white;
}
.wizard-input:checked + .wizard-label:hover {
  background: #0056b3;
}
.wizard-text {
  width: 100%;
  height: 100%;
  font-size: 2em;
  padding: 20px;
  background: #fff;
  color: #000;
  border: none;
  outline: none;
  resize: none;
}
  </style>
</head>
<body>
  <div id="gate" style="position:fixed;inset:0;background:#000;display:flex;align-items:center;justify-content:center;z-index:9999">
    <button onclick="init()" style="font-size:4em;padding:40px">üìÅ PICK FOLDER</button>
  </div>
  <div id="app">
    <div id="mode-camera" class="mode">
      <video id="camera" autoplay playsinline onclick="uiCapture('rapid')"></video>
      <div class="fixed-controls camera-controls">
        <button onclick="cameraTorchButton()">üî¶</button>
        <button onclick="uiWizardToggler()">üêå</button>
        <button onclick="cameraFlipButton()">üîÑ</button>
      </div>
    </div>
    <div id="mode-gallery" class="mode">
      <div id="gallery"></div>
    </div>
    <div id="mode-table" class="mode">
      <div style="min-width: 626px; font-family: 'Courier New', monospace;">
        <div id="GridHeader"></div>
        <div id="GridBody"></div>
        <div class="table-controls">
          <button onclick="Table.logSelected()">LOG SELECTED</button>
          <button onclick="Table.clearSelection()">CLEAR</button>
        </div>
      </div>
    </div>
    <div id="mode-settings" class="mode">
      <button onclick="directoryPickButton()">directoryPick</button>
      <button onclick="inventoryLoadButton()">uiLoad</button>
      <div>
        <textarea id="schemaTextarea" placeholder="Schema JSON"></textarea>
        <button onclick="schemaLoadButton()">schemaLoad</button>
        <button onclick="schemaLearnButton()">schemaLearn</button>
        <button onclick="schemaSaveButton()">schemaSave</button>
      </div>
      <textarea id="output" readonly style="width: 100%; font-family: monospace; font-size: 12px; overflow-y: auto;"></textarea>
    </div>
  </div>
  <div class="fixed-controls mode-controls">
    <button onclick="uiBack()">‚¨ÖÔ∏è</button>
    <button onclick="uiNext()">‚û°Ô∏è</button>
  </div>
  <div id="wizardOverlay">
    <div id="wizardPanels" class="wizardPane"></div>
    <div id="wizardNavi"></div>
  </div>
<script src="https://cdn.jsdelivr.net/npm/eruda"></script>
<script>eruda.init();</script>
  <script>
/***** SYSTEM *****/
function log(...msgs) {
  const message = msgs.map(msg => 
    typeof msg === 'object' ? JSON.stringify(msg, null, 2) : String(msg)
  ).join(' ');
  const outputBox = document.getElementById('output');
  outputBox.value += `[${new Date().toISOString()}] ${message}\n`;
  outputBox.scrollTop = outputBox.scrollHeight;
}
async function init() {
  try {
    await directoryPickButton();
    document.getElementById('gate').style.display = 'none';
    await schemaLoadButton();
    await schemaLearnButton();
    await inventoryLoadButton();
    uiRender();
    await Camera.init();
  } catch (e) {
    log(`‚ùå init failed: ${e.message}`);
  }
}
log('script start');
/***** LOW LEVEL I/O OPERATIONS *****/
let folder;
async function directoryCheck(filename) {
  try {
    await folder.getFileHandle(filename);
    return true;
  }
  catch (e) {
    if (e.name === 'NotFoundError') return false;
    throw e;
  }
}
async function fileRead(filename) {
  log(`‚ÜòÔ∏èfileRead: ${filename}`);
  const handle = await folder.getFileHandle(filename);
  return await handle.getFile();
}
async function fileCreate(filename, data, allowOverwrite = false) {
  log(`‚ÜòÔ∏èfileCreate: ${filename}`);
  if (!allowOverwrite && await directoryCheck(filename)) {
    throw new Error(`Exists: ${filename}`);
  }
  const handle = await folder.getFileHandle(filename, {create: true});
  const writer = await handle.createWritable();
  await writer.write(data);
  await writer.close();
}
async function fileDestroy(filename) {
  log(`‚ÜòÔ∏èfileDestroy: ${filename}`);
  await folder.removeEntry(filename);
}
async function fileUpdate(oldPath, newPath) {
  log(`‚ÜòÔ∏èfileUpdate: ${oldPath} -> ${newPath}`);
  if (await directoryCheck(newPath)) {
    throw new Error(`Destination exists: ${newPath}`);
  }
  try {
    const data = await fileRead(oldPath);
    await fileCreate(newPath, data);
  } 
  catch (e) {
    log(`‚ùå fileUpdate, copy fail: `, ...arguments, e.message);
    throw new Error(`Copy failed: ${e.message}`);
  }
  try {
    await fileDestroy(oldPath);
  } 
  catch (e) {
    log(`‚ùå fileUpdate, delete fail: `, ...arguments, e.message);
    throw new Error(`Rename incomplete: ${newPath} created, ${oldPath} remains`);
  }
}
async function directoryList() {
  log(`‚ÜòÔ∏èdirectoryList`);
  const files = [];
  for await (const [name, handle] of folder.entries()) {
    if (handle.kind === 'file') files.push(name);
  }
  return files;
}
async function directoryPick() {
  log(`‚ÜòÔ∏èdirectoryPick`);
  folder = await window.showDirectoryPicker({
    mode: 'readwrite'
  });
}
async function directoryPickButton() {
  try {await directoryPick();}
  catch (e) {log("directoryPickButton: ", e.message);}
}
function inventoryFromFile(filename) {
  const lastUnderscore = filename.lastIndexOf('_');
  const values = filename.substring(0, lastUnderscore);
  const lastPart = filename.substring(lastUnderscore + 1);
  const dotIndex = lastPart.indexOf('.');
  const uuid = lastPart.substring(0, dotIndex);
  if (!/^\d{17}$/.test(uuid)) throw new Error("Bad UUID!");
  const ext = lastPart.substring(dotIndex + 1);
  return {
    [uuid]: {
      ext: ext,
      values: values,
      thumbnail: null
    }
  };
}
function fileFromInventory(entry) {
  log(`‚ÜòÔ∏èfileFromInventory`);
  const [[uuid, item]] = Object.entries(entry);
  return `${item.values}_${uuid}.${item.ext}`;
}
function metadataDefault() {
  log(`‚ÜòÔ∏èmetadataDefault`);
  const now = new Date();
  const year = now.getFullYear();                                      //4
  const month = String(now.getMonth() + 1).padStart(2, '0');           //2
  const day = String(now.getDate()).padStart(2, '0');                  //2
  const hour = String(now.getHours()).padStart(2, '0');                //2
  const min = String(now.getMinutes()).padStart(2, '0');               //2
  const sec = String(now.getSeconds()).padStart(2, '0');               //2
  const mil = String(now.getMilliseconds()).padStart(3, '0');          //3
  const timestamp = `${year}${month}${day}${hour}${min}${sec}${mil}`;  //4+2+2+2+2+2+3 = 17
  return {
    [timestamp]: {
      ext: "jpg",
      values: "",
      thumbnail: null
    }
  };
}
function valuesStringToArray(valuesString, schema = null) {
  log(`‚ÜòÔ∏èvaluesStringToArray: ${valuesString}`);
  if (!valuesString) return [];
  const parts = valuesString.split('_');
  const result = parts.map((part, index) => {
    if (schema?.[index]?.type === 'multiple') {
      return part ? part.split(',') : [];
    } else {
      return part ? [part] : [];
    }
  });
  return result;
}
function valuesArrayToString(valuesArray) {
  log(`‚ÜòÔ∏èvaluesArrayToString`);
  return valuesArray.map(fieldArray => fieldArray.join(',')).join('_');
}
/***** UUID CATALOGUE (INVENTORY) *****/
let inventory = {};
async function inventoryCreate(entry, imageData) {
  log(`‚ÜòÔ∏èinventoryCreate: ${entry}`);
  const filename = fileFromInventory(entry);
  const response = await fetch(imageData);
  const blob = await response.blob();
  await fileCreate(filename, blob);
  inventory = {...inventory, ...entry};
}
async function inventoryReadFast(uuid) {
  return inventory[uuid] 
    ? { [uuid]: inventory[uuid] }
    : inventoryRead(uuid);
}
async function inventoryRead(uuid) {
  log(`‚ÜòÔ∏èinventoryRead: ${uuid}`);
  let filename = null;
  const item = inventory[uuid];
  if (item) {
    const choppedEntry = {[uuid]: item};
    const reconstructedFilename = fileFromInventory(choppedEntry);
    if (await directoryCheck(reconstructedFilename)) {
      filename = reconstructedFilename;
    }
  }
  if (!filename) {
    const candidateFiles = (await directoryList()).filter(name => 
      name.match(`_${uuid}\\.`)
    );
    if (!candidateFiles.length) {
      log(`‚ùå inventoryRead: UUID ${uuid} not found in filesystem`);
      return null;
    }
    if (candidateFiles.length === 1) {
      filename = candidateFiles[0];
    } else {
      const filesWithTimestamps = await Promise.all(
        candidateFiles.map(async name => ({
          filename: name,
          lastModified: (await (await folder.getFileHandle(name)).getFile()).lastModified
        }))
      );
      filename = filesWithTimestamps
        .sort((a, b) => b.lastModified - a.lastModified)[0]
        .filename;
    }
  }
  const choppedEntry = inventoryFromFile(filename);
  if (!choppedEntry) {
    log(`‚ùå inventoryRead: Failed to parse ${filename}`);
    return null;
  }
  inventory = { ...inventory, ...choppedEntry };
  log(`‚úì inventoryRead: Synced ${uuid} from ${filename}`);
  return {[uuid]: inventory[uuid]};
}
async function inventoryUpdate(newEntry) {
  const [[uuid, newItem]] = Object.entries(newEntry);
  const oldEntry = {[uuid]: inventory[uuid]};
  const oldFilename = fileFromInventory(oldEntry);
  const newFilename = fileFromInventory(newEntry);
  await fileUpdate(oldFilename, newFilename);
  inventory = {...inventory, ...newEntry};
}
// DESTROY
async function inventoryDestroy(uuid) {
  log(`‚ÜòÔ∏èinventoryDestroy: ${uuid}`);
  const filename = fileFromInventory({[uuid]:inventory[uuid]});
  await fileDestroy(filename);
  delete inventory[uuid];
}
async function inventoryLoad() {
  log(`‚ÜòÔ∏èinventoryLoad`);
  const filenames = await directoryList();
  inventory = {}; 
  for (const filename of filenames) {
    try { inventory = { ...inventory, ...inventoryFromFile(filename)}; }
    catch (e) { log(`inventoryLoad: `, filename, e.message); }
  }
}
async function inventoryLoadButton() {
  log(`‚ÜòÔ∏èinventoryLoadButton`);
  try {await inventoryLoad();}
  catch (e) {log(`inventoryLoadButton: `, e.message);}
}
/***** HIGH-LEVEL CAPTURE *****/
async function uiCapture(rapid = true) {
  log(`‚ÜòÔ∏èuiCapture`);
  try {
    if (!Camera.Ok()) {
      await Camera.init();
    }
    const imageData = Camera.capture();
    const entry = metadataDefault();
    const [[uuid, item]] = Object.entries(entry);
    if (uiWizardToggle) {
      item.values = await Wizard.record();
    }
    await inventoryCreate(entry, imageData);
    inventory[uuid].thumbnail = await galleryThumbnailCreate(imageData);
    log(`üì∏ ${uuid}`);
  } 
  catch (e) {
    log(`‚ùå uiCapture: `, e.message);
    if (!Camera.stream?.active) { Camera.stream = null; }
    return null;
  }
}
/***** CAMERA *****/
const Camera = {
  stream: null,
  video: null,
  track: null,
  Ok() {
    return this.stream?.active && this.video?.videoWidth > 0;
  },
  async init() {
    log(`‚ÜòÔ∏èCamera.init()`);
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: 'environment' } }
      });
      this.video = document.getElementById('camera');
      this.video.srcObject = this.stream;
      this.track = this.stream.getVideoTracks()[0];
      await new Promise((resolve, reject) => {
        this.video.addEventListener('loadedmetadata', resolve, { once: true });
        setTimeout(() => reject(new Error("Camera stream metadata load timeout.")), 5000);
      });
    } catch (e) {
      log(`‚ùå Camera.init() failed: `, e.message);
      throw e;
    }
  },
  async flip() {
    log(`‚ÜòÔ∏èCamera.flip()`);
    const currentMode = this.track?.getSettings()?.facingMode || 'environment';
    if (this.stream) {
      this.stream.getTracks().forEach(t => t.stop());
      this.stream = null;
      this.track = null;
    }
    const newMode = (currentMode === 'environment') ? 'user' : 'environment';
    this.stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: newMode } }
    });
    this.video.srcObject = this.stream;
    this.track = this.stream.getVideoTracks()[0];
    await new Promise((resolve, reject) => {
      this.video.addEventListener('loadedmetadata', resolve, { once: true });
      setTimeout(() => reject(new Error("Camera flip timeout")), 5000);
    });
  },
  async torch() {
    log(`‚ÜòÔ∏èCamera.torch()`);
    if (!this.track) return;
    const currentTorchState = this.track.getSettings().torch || false;
    await this.track.applyConstraints({
      advanced: [{ torch: !currentTorchState }]
    });
  },
  capture() {
    log(`‚ÜòÔ∏èCamera.capture()`);
    if (!this.Ok()) {
      throw new Error("Camera not ready for capture.");
    }
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = this.video.videoWidth;
    canvas.height = this.video.videoHeight;
    ctx.drawImage(this.video, 0, 0);
    return canvas.toDataURL('image/jpeg');
  }
};
async function cameraFlipButton() {
  log(`‚ÜòÔ∏ècameraFlipButton`);
  try {await Camera.flip();}
  catch (e) {log(`‚ùå cameraFlipButton: `, e.message);}
}
async function cameraTorchButton() {
  log(`‚ÜòÔ∏ècameraTorchButton`);
  try {await Camera.torch();}
  catch (e) {log(`‚ùå cameraTorchButton: `, e.message);}
}
/***** UI OPERATIONS *****/
const uiModes = {
  'mode-camera': 'üì∏',
  'mode-gallery': 'üñºÔ∏è',
  'mode-table': 'üìä',
  'mode-settings': '‚öôÔ∏è'
};
const uiArray = Object.keys(uiModes);
let uiIndex = 0;
let uiWizardToggle = false;
function uiNext() {
  log(`‚ÜòÔ∏èuiNext`);
  uiIndex = (uiIndex + 1) % uiArray.length;
  uiRender();
  Wizard.kill();
}
function uiBack() {
  log(`‚ÜòÔ∏èuiBack`);
  uiIndex = uiIndex ? uiIndex - 1 : uiArray.length - 1;
  uiRender();
  Wizard.kill();
}
function uiRender() {
  log(`‚ÜòÔ∏èuiRender`);
  const name = uiArray[uiIndex];
  document.querySelectorAll('.mode').forEach(m => m.classList.remove('active'));
  document.getElementById(name).classList.add('active');
  if (name === 'mode-gallery') galleryLoad();
  if (name === 'mode-table') Table.init();
}
function uiWizardToggler() {
  log(`‚ÜòÔ∏èuiWizardToggler`);
  uiWizardToggle = !uiWizardToggle;
  const buttons = document.querySelectorAll('.camera-controls button');
  buttons.forEach(btn => {
    if (btn.onclick?.toString().includes('uiWizardToggler')) {
      btn.textContent = uiWizardToggle ? '‚ö°' : 'üêå';
    }
  });
}
/***** DYNAMIC SCHEMA SYSTEM *****/
// RESILIENT PARSING + DEFAULTS: schemaLoad should return default schema structure if all files fail, not empty string. schemaAnalyze should continue processing remaining files when individual inventoryFromFile calls fail, logging specific problematic filenames. SchemaLearn should never throw - always produce usable schema.
let schemaText = document.getElementById('schemaTextarea');
schemaText.value = '[]';
schemaText.addEventListener('input', () => { schemaDirty = true; });
let schemaDirty = false;
const SCHEMANAME = 'schema.json';
// NEEDS CHANGE: Should use fileRead function for consistency. Should not throw - return default schema object if all loads fail.
async function schemaLoad() {
  log(`‚ÜòÔ∏èschemaLoad`);
  try {
    const file = await fileRead(SCHEMANAME);
    const content = await file.text();
    log(`üìÑ Loaded ${SCHEMANAME}`);
    return content;
  } 
  catch (e) {
    log(`‚ùå schemaLoad: `, e.message);
    return '[]';
  }
}
async function schemaLoadButton() {
  log(`‚ÜòÔ∏èschemaLoadButton`);
  try {schemaText.value=await schemaLoad();schemaDirty=false;}
  catch(e) {log(e.message);}
}
async function schemaSave() {
  log(`‚ÜòÔ∏èschemaSave`);
  await fileCreate(SCHEMANAME, schemaText.value, true);
  log(`üíæ Schema saved to ${SCHEMANAME}`);
}
async function schemaSaveButton() {
  log(`‚ÜòÔ∏èschemaSaveButton`);
  try {await schemaSave(); schemaDirty=false;}
  catch(e) {log(`‚ùå schemaSaveButton: `, e.message);}
}
function schemaMergeOptions(fieldoptions1, fieldoptions2) {
  log(`‚ÜòÔ∏èschemaMergeOptions`);
  const allOptions = [
    ...(fieldoptions1 || []),
    ...(fieldoptions2 || [])
  ];
  const uniqueOptions = allOptions.filter((option, index, self) => self.indexOf(option) === index);
  return uniqueOptions;
}
const schemaHierarchy = { "single": 1, "multiple": 2, "text": 3 };
function schemaFieldUpgrade(currentType, newType) {
  return schemaHierarchy[newType] > schemaHierarchy[currentType] ? newType : currentType;
}
//analyzeFieldPattern has a hidden fragility - it accidentally works because of array-to-string coercion.
function analyzeFieldPattern(collection) {
  log(`‚ÜòÔ∏èanalyzeFieldPattern`);
  const items = collection.filter(Boolean);
  if (!items.length) {
    return { type: 'single', options: [] };
  }
  let hasText = false;
  let hasMultiple = false;
  const tokens = new Set();
  items.forEach(item => {
    const segments = item.split(',');
    const exceedsThreshold = segments.some(segment => segment.length > 26);
    if (exceedsThreshold) {
      hasText = true;
      tokens.add(item);
    } else if (segments.length > 1) {
      hasMultiple = true;
      segments.forEach(segment => tokens.add(segment));
    } else {
      tokens.add(item);
    }
  });
  const fieldType = 
    hasText ? 'text' : 
    hasMultiple ? 'multiple' : 
    'single';
  const result = { type: fieldType };
  if (fieldType !== 'text') {
    result.options = [...tokens];
  }
  return result;
}
function schemaAnalyze(filenames) {
  log(`‚ÜòÔ∏èschemaAnalyze`);
  let inventoryFake = {};
  const imageFiles = filenames.filter(f => /\.(jpg|jpeg|png|gif)$/i.test(f));
  for (const filename of imageFiles) {
    const entry = inventoryFromFile(filename);
    if (entry) inventoryFake = { ...inventoryFake, ...entry };
  }
  const allItems = Object.values(inventoryFake);
  if (!allItems.length) return [];
  const allParsedValues = allItems.map(item => {
    return valuesStringToArray(item.values, null);
  });
  const maxFields = Math.max(...allParsedValues.map(v => v.length));
  const fieldCollections = Array.from({ length: maxFields }, () => []);
  allParsedValues.forEach(parsedArray => {
    parsedArray.forEach((fieldArray, fieldIndex) => {
      if (fieldArray.length > 0) fieldCollections[fieldIndex].push(...fieldArray);
    });
  });
  return fieldCollections.map((collection, index) => {
    const pattern = analyzeFieldPattern(collection);
    return {
      name: `field${index}`,
      type: pattern.type,
      ...(pattern.type !== 'text' && { options: pattern.options })
    };
  });
}
function schemaFuse(schema1, schema2) {
  log(`‚ÜòÔ∏èschemaFuse`);
  if (!Array.isArray(schema1)) schema1 = [];
  if (!Array.isArray(schema2)) schema2 = [];
  const result = [];
  const maxLength = Math.max(schema1.length, schema2.length);
  for (let i = 0; i < maxLength; i++) {
    const field1 = schema1[i];
    const field2 = schema2[i];
    if (field1 && field2) {
      const mergedOptions = schemaMergeOptions(field1.options, field2.options);
      const finalType = schemaFieldUpgrade(field1.type, field2.type);
      result[i] = {
        name: field1.name || field2.name,
        type: finalType,
        ...(mergedOptions && { options: mergedOptions })
      };
    } else if (field1) {
      result[i] = { ...field1 };
    } else if (field2) {
      result[i] = { ...field2 };
    }
  }
  return result;
}
async function schemaLearn() {
  log(`‚ÜòÔ∏èschemaLearn`);
  const fileList = await directoryList();
  if (fileList.length === 0) {
    log('‚ÑπÔ∏è No files found for learning');
    return;
  }
  log(`üß† Learning from ${fileList.length} files...`);
  const learnedSchema = schemaAnalyze(fileList);
  const currentSchema = schemaFromText(schemaText.value);
  const fusedSchema = schemaFuse(currentSchema, learnedSchema);
  schemaText.value = schemaToText(fusedSchema);
  schemaDirty = true;
  log('üéì Schema learning complete');
}
async function schemaLearnButton() {
  log(`‚ÜòÔ∏èschemaLearnButton`);
  try {await schemaLearn(); schemaDirty=true;}
  catch(e) {log(`‚ùå schemaLearnButton`, e.message);}
}
async function schemaInit() {
  log(`‚ÜòÔ∏èschemaInit`);
  schemaText.value = await schemaLoad();
  schemaDirty = false;
  await schemaLearn();
}
function schemaFromText(text) {
  log(`‚ÜòÔ∏èschemaFromText`);
  try {
    if (text == null) throw new Error(`Bit nothin`);
    const parsed = JSON.parse(text);
    return Array.isArray(parsed) ? parsed : [];
  } 
  catch (e) {
    log(`‚ùå schemaFromText:`, ...arguments, e.message);
    return [];
  }
}
function schemaToText(schema) {
  log(`‚ÜòÔ∏èschemaToText `);
  try {
    if (schema == null) throw new Error(`Bit nothin`);
    return JSON.stringify(schema, null, 2);
  } 
  catch (e) {
    log("‚ùå schemaToText: ", e.message);
    return '';
  }
}
function schemaGet() {
  log(`‚ÜòÔ∏èschemaGet`);
  return schemaFromText(schemaText.value);
}
/***** GALLERY *****/
const CACHENAME = 'cache.json';
async function galleryLoad() {
  log(`‚ÜòÔ∏ègalleryLoad`);
  try {
    const gallery = document.getElementById('gallery');
    gallery.innerHTML = '';
    await cacheLoad();
    for (const uuid in inventory) {
      await new Promise(resolve => requestAnimationFrame(resolve));
      if (uiArray[uiIndex] !== 'mode-gallery') return;
      const thumbnailDataURL = await galleryThumbnailGet(uuid);
      if (thumbnailDataURL) {
        const galleryImg = galleryImageElementCreate(uuid, thumbnailDataURL);
        gallery.appendChild(galleryImg);
      }
    }
    await cacheSave();
  } 
  catch (e) {
    log(`‚ùå galleryLoad: `, e.message);
  }
}
// prevent single image failure from breaking entire gallery
async function cacheLoad() {
  log(`‚ÜòÔ∏ècacheLoad`);
  try {
    const cacheFile = await fileRead(CACHENAME);
    const cacheText = await cacheFile.text();
    const cacheData = JSON.parse(cacheText);
    for (const uuid in cacheData) {
      if (inventory[uuid]) {
        inventory[uuid].thumbnail = cacheData[uuid].thumbnail;
      }
    }
    return cacheData;
  } 
  catch (e) {
    log(`‚ùå cacheLoad:`, e.message);
    return {};
  }
}
async function cacheSave() {
  log(`‚ÜòÔ∏ècacheSave`);
  try {
    const cacheData = {};
    for (const uuid in inventory) {
      if (inventory[uuid].thumbnail) {
        cacheData[uuid] = {
          thumbnail: inventory[uuid].thumbnail
        };
      }
    }
    const cacheJSON = JSON.stringify(cacheData);
    const blob = new Blob([cacheJSON], {type: 'application/json' });
    await fileCreate(CACHENAME, blob, true);
  } 
  catch (e) {
    log(`‚ùå cacheSave:`, e.message);
  }
}
// no error handling, let error fly
async function galleryThumbnailGet(uuid) {
  log(`‚ÜòÔ∏ègalleryThumbnailGet: ${uuid}`);
  if (inventory[uuid]?.thumbnail) {
    return inventory[uuid].thumbnail;
  }
  const item = inventory[uuid];
  if (!item) return null;
  const entry = {[uuid]: item};
  const filename = fileFromInventory(entry);
  const file = await fileRead(filename);
  const thumbnailDataURL = await galleryThumbnailCreate(file);
  inventory[uuid].thumbnail = thumbnailDataURL;
  return thumbnailDataURL;
}
async function galleryThumbnailCreate(file) {
  log(`‚ÜòÔ∏ègalleryThumbnailCreate`);
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const img = new Image();
  const imgUrl = URL.createObjectURL(file);
  return new Promise((resolve) => {
    img.onload = () => {
      URL.revokeObjectURL(imgUrl);
      const size = 512;
      canvas.width = size;
      canvas.height = size;
      ctx.drawImage(img, 0, 0, size, size);
      const dataURL = canvas.toDataURL('image/jpeg', 0.8);
      resolve(dataURL);
    };
    img.src = imgUrl;
  });
}
function galleryImageElementCreate(uuid, thumbnailDataURL) {
  log(`‚ÜòÔ∏ègalleryImageElementCreate: ${uuid}`);
  const galleryImg = document.createElement('img');
  galleryImg.src = thumbnailDataURL;
  galleryImg.className = 'gallery-item';
  galleryImg.loading = 'lazy';
  galleryImg.onclick = async () => {
    const item = inventory[uuid];
    if (!item) return;
    const entry = {[uuid]: item};
    const filename = fileFromInventory(entry);
    if (!filename) {
      log(`‚ùå galleryImageElementCreate: ${uuid}`);
      return;
    }
    const file = await fileRead(filename);
    const originalUrl = URL.createObjectURL(file);
    const popup = window.open('', '_blank');
    popup.document.write(`<img src="${originalUrl}" style="max-width:100%;max-height:100%;">`);
  };
  return galleryImg;
}
/***** TABLE SPREADSHEET *****/
const Table = (function() {
  const dataKeys = {uuid:'data-uuid', id:'data-cell-id'};
  let selectedCells = new Set();
  let editingCellId = null;
  let pressTimer = null;
  let startX = 0, startY = 0;
  const longPressTime = 500, moveTolerance = 10;

  function clearSelection() {
    log('‚ÜòÔ∏èTable.clearSelection');
    document.querySelectorAll('.Selected').forEach(c => c.classList.remove('Selected'));
    selectedCells.clear();
  }
  
  function toggleSelection(element, id) {
    log(`‚ÜòÔ∏èTable.toggleSelection: ${id}`);
    selectedCells.has(id) ? selectedCells.delete(id) : selectedCells.add(id);
    element.classList.toggle('Selected');
  }
  
  function logSelected() {
    log('‚ÜòÔ∏èTable.logSelected:', [...selectedCells]);
  }
  
  function createHeader() {
    log('‚ÜòÔ∏èTable.createHeader');
    const header = document.getElementById('GridHeader');
    header.innerHTML = '';
    const schema = schemaGet();
    
    // ACT column
    const actCell = document.createElement('div');
    actCell.className = 'headerCell cell';
    actCell.textContent = 'ACT';
    header.appendChild(actCell);
    
    // Schema-driven columns
    schema.forEach(field => {
      const c = document.createElement('div');
      c.className = 'headerCell cell';
      c.textContent = field.name;
      header.appendChild(c);
    });
  }
  
  function parseInventoryToFields(uuid) {
    log(`‚ÜòÔ∏èTable.parseInventoryToFields: ${uuid}`);
    const item = inventory[uuid];
    if (!item) return null;
    
    const valuesArray = valuesStringToArray(item.values, schemaGet());
    
    // Map valuesArray to fieldNames based on schema
    const fields = {};
    const schema = schemaGet();
    
    schema.forEach((field, index) => {
      const fieldValue = valuesArray[index] || [];
      fields[field.name] = fieldValue.join(',');
    });
    
    return fields;
  }
  
  function saveEdit(uuid, fieldName, input, masterCell) {
    log(`‚ÜòÔ∏èTable.saveEdit: ${uuid}::${fieldName}`);
    const newValue = input.value;
    
    if (selectedCells.size > 0) {
      // Batch edit
      selectedCells.forEach(cellId => {
        const [targetUuid, targetField] = cellId.split('::');
        updateInventoryField(targetUuid, targetField, newValue);
        
        const targetElement = document.querySelector(`[${dataKeys.id}="${cellId}"]`);
        if (targetElement) {
          targetElement.textContent = newValue;
          targetElement.classList.remove('Selected');
        }
      });
    } else {
      // Single edit
      updateInventoryField(uuid, fieldName, newValue);
    }
    
    masterCell.innerHTML = '';
    masterCell.textContent = newValue;
    masterCell.classList.remove('Editing');
    clearSelection();
    editingCellId = null;
  }
  
  function updateInventoryField(uuid, fieldName, newValue) {
    log(`‚ÜòÔ∏èTable.updateInventoryField: ${uuid}.${fieldName} = ${newValue}`);
    
    const item = inventory[uuid];
    if (!item) return;
    
    const valuesArray = valuesStringToArray(item.values, schemaGet());
    const schema = schemaGet();
    
    // Find field index in schema
    const fieldIndex = schema.findIndex(f => f.name === fieldName);
    if (fieldIndex === -1) return;
    
    // Update the specific field
    if (schema[fieldIndex].type === 'multiple') {
      valuesArray[fieldIndex] = newValue ? newValue.split(',') : [];
    } else {
      valuesArray[fieldIndex] = newValue ? [newValue] : [];
    }
    
    // Convert back to string
    const newValuesString = valuesArrayToString(valuesArray);
    
    // Update inventory
    const oldEntry = {[uuid]: item};
    const newEntry = {[uuid]: {...item, values: newValuesString}};
    
    // Trigger file update
    inventoryUpdate(newEntry).catch(e => log(`‚ùå Table.updateInventoryField: ${e.message}`));
  }
  
  function handleTap(e, uuid, fieldName, cellId) {
    log(`‚ÜòÔ∏èTable.handleTap: ${cellId}`);
    e.stopPropagation();
    
    if (editingCellId) {
      const editInput = document.querySelector(`[${dataKeys.id}="${editingCellId}"] input`);
      if (editInput) editInput.blur();
    }
    
    const cell = e.currentTarget;
    if (!selectedCells.has(cellId)) clearSelection();
    
    editingCellId = cellId;
    cell.classList.add('Editing');
    
    const fields = parseInventoryToFields(uuid);
    const currentValue = fields ? fields[fieldName] : '';
    
    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentValue;
    cell.textContent = '';
    cell.appendChild(input);
    input.focus();
    
    input.onblur = () => saveEdit(uuid, fieldName, input, cell);
    input.onkeydown = ev => {
      ev.stopPropagation();
      if (ev.key === 'Enter') ev.currentTarget.blur();
    };
  }
  
  function handlePressStart(e) {
    if (editingCellId) return;
    
    const cell = e.currentTarget;
    const cellId = cell.getAttribute(dataKeys.id);
    startX = e.touches[0].clientX;
    startY = e.touches[0].clientY;
    
    pressTimer = setTimeout(() => {
      toggleSelection(cell, cellId);
      pressTimer = null;
    }, longPressTime);
  }
  
  function handlePressMove(e) {
    if (!pressTimer) return;
    const dx = Math.abs(e.touches[0].clientX - startX);
    const dy = Math.abs(e.touches[0].clientY - startY);
    if (dx > moveTolerance || dy > moveTolerance) {
      clearTimeout(pressTimer);
      pressTimer = null;
    }
  }
  
  function handlePressEnd(e) {
    if (pressTimer) clearTimeout(pressTimer);
  }
  
  function renderInventory() {
    log('‚ÜòÔ∏èTable.renderInventory');
    const body = document.getElementById('GridBody');
    body.innerHTML = '';
    
    Object.entries(inventory).forEach(([uuid, item]) => {
      const row = document.createElement('div');
      row.className = 'Row';
      row.setAttribute(dataKeys.uuid, uuid);
      
      // Thumbnail cell
      const thumbCell = document.createElement('div');
      thumbCell.className = 'Cell ThumbCell';
      thumbCell.setAttribute(dataKeys.id, `${uuid}::t`);
      
      // Check if thumbnail exists in inventory
      if (inventory[uuid].thumbnail) {
        const thumbImg = document.createElement('img');
        thumbImg.src = inventory[uuid].thumbnail;
        thumbImg.style.cssText = 'width:38px;height:38px;object-fit:cover;cursor:pointer';
        thumbImg.onclick = e => {
          e.stopPropagation();
          if (!editingCellId) {
            log(`Navigate to gallery: ${uuid}`);
            // TODO: Navigate to gallery and focus on this item
          }
        };
        thumbCell.appendChild(thumbImg);
      } else {
        const thumbDiv = document.createElement('div');
        thumbDiv.className = 'Thumb';
        thumbDiv.textContent = 'üì∑';
        thumbDiv.onclick = e => {
          e.stopPropagation();
          if (!editingCellId) {
            log(`Navigate to gallery: ${uuid}`);
          }
        };
        thumbCell.appendChild(thumbDiv);
      }
      
      thumbCell.appendChild(thumbDiv);
      row.appendChild(thumbCell);
      
      // Data cells - schema-driven
      const fields = parseInventoryToFields(uuid);
      if (!fields) return;
      
      const schema = schemaGet();
      schema.forEach(schemaField => {
        const cell = document.createElement('div');
        const cellId = `${uuid}::${schemaField.name}`;
        cell.className = 'cell dataCell';
        cell.setAttribute(dataKeys.id, cellId);
        cell.textContent = fields[schemaField.name] || '';
        
        if (selectedCells.has(cellId)) cell.classList.add('Selected');
        
        cell.onclick = e => handleTap(e, uuid, schemaField.name, cellId);
        cell.addEventListener('touchstart', handlePressStart);
        cell.addEventListener('touchmove', handlePressMove);
        cell.addEventListener('touchend', handlePressEnd);
        
        row.appendChild(cell);
      });
      
      body.appendChild(row);
    });
  }
  
  function init() {
    log('‚ÜòÔ∏èTable.init');
    createHeader();
    renderInventory();
  }
  
  return {
    init,
    clearSelection,
    logSelected
  };
})();
// DISCUSSION: How to make components more robust?
// RESILIENT INPUT + NON-BLOCKING: Wizard failures return empty metadata rather than throwing. Input validation warns but doesn't prevent progression. Build functions handle missing schema gracefully.
/***** WIZARD OVERLAY *****/
const Wizard = (function() {
  let wizardOverlay;
  let wizardPanels;
  let navi;
  let schema;
  let values;
  let step;
  let resolve;
  let reject;
  function gridSizer(buttonCount, aspectRatio) {
    log(`‚ÜòÔ∏èWizard.gridSizer`);
    let bestRows = 1;
    let bestCols = buttonCount;
    let bestSkinny = 0.0;
    for (let rows = 1; rows <= buttonCount; rows++) {
      const cols = Math.ceil(buttonCount / rows);
      const width = aspectRatio / cols;
      const height = 1.0 / rows;
      const nowSkinny = Math.min(width, height);
      if (nowSkinny > bestSkinny) {
        bestSkinny = nowSkinny;
        bestRows = rows;
        bestCols = cols;
      }
    }
    return { rows: bestRows, cols: bestCols };
  }
  function refresh() {
    log(`‚ÜòÔ∏èWizard.refresh`);
    if (step < 0) {
      step = 0;
    } else if (step >= schema.length) {
      done();
      return;
    }
    const screens = Array.from(wizardPanels.children);
    screens.forEach((screen, index) => {
      if (index === step) {
        screen.classList.add('active');
      } else {
        screen.classList.remove('active');
      }
    });
  }
  function init() {
    log(`‚ÜòÔ∏èWizard.init`);
    wizardOverlay = document.getElementById('wizardOverlay');
    wizardPanels = document.getElementById('wizardPanels');
    wizardPanels.innerHTML = '';
    navi = document.getElementById('wizardNavi');
    navi.innerHTML = '';
    [
      {textContent: '‚¨ÖÔ∏è', onclick: back},
      {textContent: '‚ùå', onclick: kill},
      {textContent: 'üíæ', onclick: done},
      {textContent: '‚û°Ô∏è', onclick: next}
    ].forEach(config => {
      const button = document.createElement('button');
      Object.assign(button, config, { className: 'nav-button' });
      navi.appendChild(button);
    });
  }
  function build() {
    log(`‚ÜòÔ∏èWizard.build`);
    schema.forEach((_, index) => {
      const screen = document.createElement('div');
      screen.className = 'wizard-screen';
      buildScreenContent(screen, index);
      wizardPanels.appendChild(screen);
    });
  }
  // CHANGE?
  function buildScreenContent(screen, index) {
    log(`‚ÜòÔ∏èWizard.buildScreenContent`);
    const field = schema[index];
    if (field.type === 'text') {
      screen.style.cssText = 'grid-template-columns:1fr;grid-template-rows:1fr';
      const textarea = document.createElement('textarea');
      textarea.className = 'wizard-text';
      textarea.placeholder = `Enter ${field.name}`;
      textarea.value = values[index] ? values[index].join(',') : '';
      textarea.oninput = () => {
        values[index] = [textarea.value];
      };
      screen.appendChild(textarea);
    } else {
      const availableHeight = window.innerHeight - 80;
      const availableWidth = window.innerWidth;
      const grid = gridSizer(field.options.length, availableWidth / availableHeight);
      screen.style.cssText = `grid-template-columns:repeat(${grid.cols},1fr);grid-template-rows:repeat(${grid.rows},1fr)`;
      field.options.forEach((option, optionIndex) => {
        const input = document.createElement('input');
        input.value = option;
        input.className = 'wizard-input';
        input.name = `field-${index}`;
        const id = `field-${index}-${field.name}-${optionIndex}`;
        input.id = id;
        if (field.type === 'multiple') {
          input.type = 'checkbox';
          //if (values[index] && values[index].includes(option)) {input.checked = true;}
          input.onchange = () => {
            const checkedInputs = screen.querySelectorAll('input[type="checkbox"]:checked');
            values[index] = Array.from(checkedInputs).map(inp => inp.value);
          };
        } else if (field.type === 'single') {
          input.type = 'radio';
          //if (values[index] && values[index][0] === option) {input.checked = true;}
          input.onchange = () => {
            values[index] = [option];
            next();
          };
        }
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'wizard-label';
        button.textContent = option;
        button.onclick = () => {
          input.checked = !input.checked;
          input.onchange();
        };
        screen.appendChild(input);
        screen.appendChild(button);
      });
    }
  }
//  AI OMITTED THIS FUNCTION DURING METADATA AND INVENTORY BLUEPRPINT ARCHITECTURE REFACTOR
//  function mergeMetadata(metadata1, metadata2) {
//    log(`‚ÜòÔ∏èmergeMetadata`);
//    const mergedResult = { ...metadata1 , ...metadata2 };
//    mergedResult.data = {...metadata1.data, ...metadata2.data};
//    const isEmptyArray = x => Array.isArray(x) && x.length === 0;
//    const maxLength = Math.max(metadata1.values?.length ?? 0, metadata2.values?.length ?? 0)
//    mergedResult.values = Array.from({ length: maxLength }, (_, i) =>
//      isEmptyArray(metadata2?.values[i]||[]) ?
//        (isEmptyArray(metadata1?.values[i]||[]) ?
//          []
//          :
//         metadata1.values[i])
//        :
//        metadata2.values[i]
//    );
//    return mergedResult;
//  }
  function record() {
    log(`‚ÜòÔ∏èWizard.record`);
    values = [];
    step = 0;
    schema = schemaGet();
    init();
    build();
    wizardOverlay.style.display = 'flex';
    return new Promise((res, rej) => {
      resolve = res;
      reject = rej;
      refresh();
    });
  }
  // DISCUSSION: If the wizard fails for some reason, should it return an empty metadata? Should the calling function save the image with empty metadata?
  function kill() {
    log(`‚ÜòÔ∏èWizard.kill`);
    wizardOverlay.style.display = 'none';
    if (reject) {
      reject(new Error('WIZARD_KILLED'));
    }
  }
  function done() {
    log(`‚ÜòÔ∏èWizard.done`);
    wizardOverlay.style.display = 'none';
    if (resolve) {
      const rawString = valuesArrayToString(values);
      resolve(rawString);
    }
  }
  function back() {
    log(`‚ÜòÔ∏èWizard.back`);
    step--;
    refresh();
  }
  function next() {
    log(`‚ÜòÔ∏èWizard.next`);
    step++;
    refresh();
  }
  return { record, kill, done, back, next };
})();
log('script end');
  </script>
</body>
</html>
