<!DOCTYPE html>
<html>
<head>
  <title>InvtSysShell3+ v18.20+</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
/***** RESET *****/
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
/***** LAYOUT *****/
body {
  height: 100vh;
  font-family: system-ui, -apple-system, sans-serif;
  overflow: hidden;
}
/***** UNIVERSAL BUTTON *****/
button {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2em;
  padding: 10px;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  user-select: none;
  background: rgba(0, 0, 0, 0.5);
  color: white;
}
button:hover {
  background: rgba(0, 0, 0, 0.7);
}
button:active {
  background: rgba(0, 0, 0, 0.9);
}
/***** FIXED CONTROLS *****/
.controls-fixed {
  position: fixed;
  display: flex;
  gap: 10px;
  z-index: 100;
}
.controls-mode {
  top: 20px;
  left: 20px;
  right: 20px;
  z-index: 1000;
  justify-content: space-between;
}
.controls-camera {
  bottom: 20px;
  left: 20px;
  right: 20px;
  z-index: 1000;
  justify-content: space-between;
}
/***** MODE SYSTEM *****/
.mode {
  display: none;
}
.mode.active {
  display: block;
  position: fixed;
  inset: 0;
  overflow-y: auto;
  overflow-x: auto;
  padding-top: 80px;
}
/***** CAMERA *****/
#c-video {
  width: 100vw;
  height: 100vh;
  object-fit: cover;
  cursor: pointer;
}
/***** GALLERY *****/
#g-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
}
.g-grid-item {
  width: 100%;
  aspect-ratio: 1;
  object-fit: cover;
  cursor: pointer;
}
/***** TABLE GRID *****/
#t-header, .table-row{
  display:grid;
  grid-template-columns:40px repeat(var(--cols),1fr);
  gap:1px
}
#t-header{
  position:sticky;
  top:0;
  background:#ccc;
  font-weight:bold
}
.table-cell{
  background:#fff;
  padding:4px;
  overflow:hidden;
  white-space:nowrap
}
.table-cell[data-state="selected"]{
  background:#8cf
}
.table-cell[data-state="editing"]{
  background:#ff8;
  padding:0
}
.table-cell input{
  width:100%;
  font:inherit;
  border:1px solid #000;
  padding:4px
}
/***** WIZARD OVERLAY *****/
#w-overlay {
  position: fixed;
  inset: 0;
  display: none;
  flex-direction: column;
  background: #000;
  padding: 2px;
  gap: 2px;
  z-index: 2000;
}
.wizard-pane {
  flex: 1;
  display: grid;
  gap: 2px;
}
.wizard-screen {
  display: none;
  background: #000;
  gap: 2px;
}
.wizard-screen.active {
  display: grid;
}
#w-navi {
  height: 80px;
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 2px;
}
#w-navi button {
  font-size: 1.5em;
  background: #333;
}
#w-navi button:hover {
  background: #555;
}
#w-navi button:active {
  background: #777;
}
/***** WIZARD INPUTS *****/
.wizard-input {
  display: none;
}
.wizard-label {
  background: #ddd;
  color: #000;
}
.wizard-label:hover {
  background: #bbb;
}
.wizard-input:checked + .wizard-label {
  background: #007bff;
  color: white;
}
.wizard-input:checked + .wizard-label:hover {
  background: #0056b3;
}
.wizard-input-text {
  width: 100%;
  height: 100%;
  font-size: 2em;
  padding: 20px;
  background: #fff;
  color: #000;
  border: none;
  outline: none;
  resize: none;
}
  </style>
</head>
<body>
  <div id="init-gate" style="position:fixed;inset:0;background:#000;display:flex;align-items:center;justify-content:center;z-index:9999">
    <button onclick="init()" style="font-size:4em;padding:40px">üìÅ PICK FOLDER</button>
  </div>
  <div id="app">
    <div id="mode-camera" class="mode">
      <video id="c-video" autoplay playsinline onclick="uiCapture('rapid')"></video>
      <div class="controls-fixed controls-camera">
        <button onclick="cameraTorchButton()">üî¶</button>
        <button onclick="uiWizardToggler()">üêå</button>
        <button onclick="cameraFlipButton()">üîÑ</button>
      </div>
    </div>
    <div id="mode-gallery" class="mode">
      <div id="g-grid"></div>
    </div>
    <div id="mode-table" class="mode">
      <div>
        <div id="t-header"></div>
        <div id="t-body"></div>
      </div>
    </div>
    <div id="mode-settings" class="mode">
      <button onclick="directoryPickButton()">directoryPick</button>
      <button onclick="inventoryLoadButton()">uiLoad</button>
      <div>
        <textarea id="schema-input" placeholder="Schema JSON"></textarea>
        <button onclick="schemaLoadButton()">schemaLoad</button>
        <button onclick="schemaLearnButton()">schemaLearn</button>
        <button onclick="schemaSaveButton()">schemaSave</button>
      </div>
      <textarea id="debug-output" readonly style="width: 100%; font-family: monospace; font-size: 12px; overflow-y: auto;"></textarea>
    </div>
  </div>
  <div class="controls-fixed controls-mode">
    <button onclick="uiBack()">‚¨ÖÔ∏è</button>
    <button onclick="uiNext()">‚û°Ô∏è</button>
  </div>
  <div id="w-overlay">
    <div id="w-panels" class="wizard-pane"></div>
    <div id="w-navi"></div>
  </div>
<script src="https://cdn.jsdelivr.net/npm/eruda"></script>
<script>eruda.init();</script>
  <script>
/***** SYSTEM *****/
function log(...msgs) {
  const message = msgs.map(msg => 
    typeof msg === 'object' ? JSON.stringify(msg, null, 2) : String(msg)
  ).join(' ');
  const outputBox = document.getElementById('debug-output');
  outputBox.value += `[${new Date().toISOString()}] ${message}\n`;
  outputBox.scrollTop = outputBox.scrollHeight;
}
async function init() {
  try {
    await directoryPickButton();
    document.getElementById('init-gate').style.display = 'none';
    await schemaLoadButton();
    await schemaLearnButton();
    await inventoryLoadButton();
    uiRender();
    await Camera.init();
  } catch (e) {
    log(`‚ùå init failed: ${e.message}`);
  }
}
log('script start');
/***** LOW LEVEL I/O OPERATIONS *****/
let folder;
async function directoryCheck(filename) {
  try {
    await folder.getFileHandle(filename);
    return true;
  }
  catch (e) {
    if (e.name === 'NotFoundError') return false;
    throw e;
  }
}
async function fileRead(filename) {
  log(`‚ÜòÔ∏èfileRead: ${filename}`);
  const handle = await folder.getFileHandle(filename);
  return await handle.getFile();
}
async function fileCreate(filename, data, allowOverwrite = false) {
  log(`‚ÜòÔ∏èfileCreate: ${filename}`);
  if (!allowOverwrite && await directoryCheck(filename)) {
    throw new Error(`Exists: ${filename}`);
  }
  const handle = await folder.getFileHandle(filename, {create: true});
  const writer = await handle.createWritable();
  await writer.write(data);
  await writer.close();
}
async function fileDestroy(filename) {
  log(`‚ÜòÔ∏èfileDestroy: ${filename}`);
  await folder.removeEntry(filename);
}
async function fileUpdate(oldPath, newPath) {
  log(`‚ÜòÔ∏èfileUpdate: ${oldPath} -> ${newPath}`);
  if (await directoryCheck(newPath)) {
    throw new Error(`Destination exists: ${newPath}`);
  }
  try {
    const data = await fileRead(oldPath);
    await fileCreate(newPath, data);
  } 
  catch (e) {
    log(`‚ùå fileUpdate, copy fail: `, ...arguments, e.message);
    throw new Error(`Copy failed: ${e.message}`);
  }
  try {
    await fileDestroy(oldPath);
  } 
  catch (e) {
    log(`‚ùå fileUpdate, delete fail: `, ...arguments, e.message);
    throw new Error(`Rename incomplete: ${newPath} created, ${oldPath} remains`);
  }
}
async function directoryList() {
  log(`‚ÜòÔ∏èdirectoryList`);
  const files = [];
  for await (const [name, handle] of folder.entries()) {
    if (handle.kind === 'file') files.push(name);
  }
  return files;
}
async function directoryPick() {
  log(`‚ÜòÔ∏èdirectoryPick`);
  folder = await window.showDirectoryPicker({
    mode: 'readwrite'
  });
}
async function directoryPickButton() {
  try {await directoryPick();}
  catch (e) {log("directoryPickButton: ", e.message);}
}
function inventoryFromFile(filename) {
  const lastUnderscore = filename.lastIndexOf('_');
  const values = filename.substring(0, lastUnderscore);
  const lastPart = filename.substring(lastUnderscore + 1);
  const dotIndex = lastPart.indexOf('.');
  const uuid = lastPart.substring(0, dotIndex);
  if (!/^\d{17}$/.test(uuid)) throw new Error("Bad UUID!");
  const ext = lastPart.substring(dotIndex + 1);
  return {
    [uuid]: {
      ext: ext,
      values: values,
      thumbnail: null
    }
  };
}
function fileFromInventory(entry) {
  log(`‚ÜòÔ∏èfileFromInventory`);
  const [[uuid, item]] = Object.entries(entry);
  return `${item.values}_${uuid}.${item.ext}`;
}
function metadataDefault() {
  log(`‚ÜòÔ∏èmetadataDefault`);
  const now = new Date();
  const year = now.getFullYear();                                      //4
  const month = String(now.getMonth() + 1).padStart(2, '0');           //2
  const day = String(now.getDate()).padStart(2, '0');                  //2
  const hour = String(now.getHours()).padStart(2, '0');                //2
  const min = String(now.getMinutes()).padStart(2, '0');               //2
  const sec = String(now.getSeconds()).padStart(2, '0');               //2
  const mil = String(now.getMilliseconds()).padStart(3, '0');          //3
  const timestamp = `${year}${month}${day}${hour}${min}${sec}${mil}`;  //4+2+2+2+2+2+3 = 17
  return {
    [timestamp]: {
      ext: "jpg",
      values: "",
      thumbnail: null
    }
  };
}
function valuesStringToArray(valuesString, schema = null) {
  log(`‚ÜòÔ∏èvaluesStringToArray: ${valuesString}`);
  if (!valuesString) return [];
  const parts = valuesString.split('_');
  const result = parts.map((part, index) => {
    if (schema?.[index]?.type === 'multiple') {
      return part ? part.split(',') : [];
    } else {
      return part ? [part] : [];
    }
  });
  return result;
}
function valuesArrayToString(valuesArray) {
  log(`‚ÜòÔ∏èvaluesArrayToString`);
  return valuesArray.map(fieldArray => fieldArray.join(',')).join('_');
}
/***** UUID CATALOGUE (INVENTORY) *****/
let inventory = {};
async function inventoryCreate(entry, imageData) {
  log(`‚ÜòÔ∏èinventoryCreate: ${entry}`);
  const filename = fileFromInventory(entry);
  const response = await fetch(imageData);
  const blob = await response.blob();
  await fileCreate(filename, blob);
  inventory = {...inventory, ...entry};
}
async function inventoryReadFast(uuid) {
  return inventory[uuid] 
    ? { [uuid]: inventory[uuid] }
    : inventoryRead(uuid);
}
async function inventoryRead(uuid) {
  log(`‚ÜòÔ∏èinventoryRead: ${uuid}`);
  let filename = null;
  const item = inventory[uuid];
  if (item) {
    const choppedEntry = {[uuid]: item};
    const reconstructedFilename = fileFromInventory(choppedEntry);
    if (await directoryCheck(reconstructedFilename)) {
      filename = reconstructedFilename;
    }
  }
  if (!filename) {
    const candidateFiles = (await directoryList()).filter(name => 
      name.match(`_${uuid}\\.`)
    );
    if (!candidateFiles.length) {
      log(`‚ùå inventoryRead: UUID ${uuid} not found in filesystem`);
      return null;
    }
    if (candidateFiles.length === 1) {
      filename = candidateFiles[0];
    } else {
      const filesWithTimestamps = await Promise.all(
        candidateFiles.map(async name => ({
          filename: name,
          lastModified: (await (await folder.getFileHandle(name)).getFile()).lastModified
        }))
      );
      filename = filesWithTimestamps
        .sort((a, b) => b.lastModified - a.lastModified)[0]
        .filename;
    }
  }
  const choppedEntry = inventoryFromFile(filename);
  if (!choppedEntry) {
    log(`‚ùå inventoryRead: Failed to parse ${filename}`);
    return null;
  }
  inventory = { ...inventory, ...choppedEntry };
  log(`‚úì inventoryRead: Synced ${uuid} from ${filename}`);
  return {[uuid]: inventory[uuid]};
}
async function inventoryUpdate(newEntry) {
  const [[uuid, newItem]] = Object.entries(newEntry);
  const oldEntry = {[uuid]: inventory[uuid]};
  const oldFilename = fileFromInventory(oldEntry);
  const newFilename = fileFromInventory(newEntry);
  await fileUpdate(oldFilename, newFilename);
  inventory = {...inventory, ...newEntry};
}
// DESTROY
async function inventoryDestroy(uuid) {
  log(`‚ÜòÔ∏èinventoryDestroy: ${uuid}`);
  const filename = fileFromInventory({[uuid]:inventory[uuid]});
  await fileDestroy(filename);
  delete inventory[uuid];
}
async function inventoryLoad() {
  log(`‚ÜòÔ∏èinventoryLoad`);
  const filenames = await directoryList();
  inventory = {}; 
  for (const filename of filenames) {
    try { inventory = { ...inventory, ...inventoryFromFile(filename)}; }
    catch (e) { log(`inventoryLoad: `, filename, e.message); }
  }
}
async function inventoryLoadButton() {
  log(`‚ÜòÔ∏èinventoryLoadButton`);
  try {await inventoryLoad();}
  catch (e) {log(`inventoryLoadButton: `, e.message);}
}
/***** HIGH-LEVEL CAPTURE *****/
async function uiCapture(rapid = true) {
  log(`‚ÜòÔ∏èuiCapture`);
  try {
    if (!Camera.Ok()) {
      await Camera.init();
    }
    const imageData = Camera.capture();
    const entry = metadataDefault();
    const [[uuid, item]] = Object.entries(entry);
    if (uiWizardToggle) {
      item.values = await Wizard.record();
    }
    await inventoryCreate(entry, imageData);
    inventory[uuid].thumbnail = await galleryThumbnailCreate(imageData);
    log(`üì∏ ${uuid}`);
  } 
  catch (e) {
    log(`‚ùå uiCapture: `, e.message);
    if (!Camera.stream?.active) { Camera.stream = null; }
    return null;
  }
}
/***** CAMERA *****/
const Camera = {
  stream: null,
  video: null,
  track: null,
  Ok() {
    return this.stream?.active && this.video?.videoWidth > 0;
  },
  async init() {
    log(`‚ÜòÔ∏èCamera.init()`);
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: 'environment' } }
      });
      this.video = document.getElementById('c-video');
      this.video.srcObject = this.stream;
      this.track = this.stream.getVideoTracks()[0];
      await new Promise((resolve, reject) => {
        this.video.addEventListener('loadedmetadata', resolve, { once: true });
        setTimeout(() => reject(new Error("Camera stream metadata load timeout.")), 5000);
      });
    } catch (e) {
      log(`‚ùå Camera.init() failed: `, e.message);
      throw e;
    }
  },
  async flip() {
    log(`‚ÜòÔ∏èCamera.flip()`);
    const currentMode = this.track?.getSettings()?.facingMode || 'environment';
    if (this.stream) {
      this.stream.getTracks().forEach(t => t.stop());
      this.stream = null;
      this.track = null;
    }
    const newMode = (currentMode === 'environment') ? 'user' : 'environment';
    this.stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: newMode } }
    });
    this.video.srcObject = this.stream;
    this.track = this.stream.getVideoTracks()[0];
    await new Promise((resolve, reject) => {
      this.video.addEventListener('loadedmetadata', resolve, { once: true });
      setTimeout(() => reject(new Error("Camera flip timeout")), 5000);
    });
  },
  async torch() {
    log(`‚ÜòÔ∏èCamera.torch()`);
    if (!this.track) return;
    const currentTorchState = this.track.getSettings().torch || false;
    await this.track.applyConstraints({
      advanced: [{ torch: !currentTorchState }]
    });
  },
  capture() {
    log(`‚ÜòÔ∏èCamera.capture()`);
    if (!this.Ok()) {
      throw new Error("Camera not ready for capture.");
    }
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = this.video.videoWidth;
    canvas.height = this.video.videoHeight;
    ctx.drawImage(this.video, 0, 0);
    return canvas.toDataURL('image/jpeg');
  }
};
async function cameraFlipButton() {
  log(`‚ÜòÔ∏ècameraFlipButton`);
  try {await Camera.flip();}
  catch (e) {log(`‚ùå cameraFlipButton: `, e.message);}
}
async function cameraTorchButton() {
  log(`‚ÜòÔ∏ècameraTorchButton`);
  try {await Camera.torch();}
  catch (e) {log(`‚ùå cameraTorchButton: `, e.message);}
}
/***** UI OPERATIONS *****/
const uiModes = {
  'mode-camera': 'üì∏',
  'mode-gallery': 'üñºÔ∏è',
  'mode-table': 'üìä',
  'mode-settings': '‚öôÔ∏è'
};
const uiArray = Object.keys(uiModes);
let uiIndex = 0;
let uiWizardToggle = false;
function uiNext() {
  log(`‚ÜòÔ∏èuiNext`);
  uiIndex = (uiIndex + 1) % uiArray.length;
  uiRender();
  Wizard.kill();
}
function uiBack() {
  log(`‚ÜòÔ∏èuiBack`);
  uiIndex = uiIndex ? uiIndex - 1 : uiArray.length - 1;
  uiRender();
  Wizard.kill();
}
function uiRender() {
  log(`‚ÜòÔ∏èuiRender`);
  const name = uiArray[uiIndex];
  document.querySelectorAll('.mode').forEach(m => m.classList.remove('active'));
  document.getElementById(name).classList.add('active');
  if (name === 'mode-gallery') galleryLoad();
  if (name === 'mode-table') Table.init();
}
function uiWizardToggler() {
  log(`‚ÜòÔ∏èuiWizardToggler`);
  uiWizardToggle = !uiWizardToggle;
  const buttons = document.querySelectorAll('.controls-camera button');
  buttons.forEach(btn => {
    if (btn.onclick?.toString().includes('uiWizardToggler')) {
      btn.textContent = uiWizardToggle ? '‚ö°' : 'üêå';
    }
  });
}
/***** DYNAMIC SCHEMA SYSTEM *****/
// RESILIENT PARSING + DEFAULTS: schemaLoad should return default schema structure if all files fail, not empty string. schemaAnalyze should continue processing remaining files when individual inventoryFromFile calls fail, logging specific problematic filenames. SchemaLearn should never throw - always produce usable schema.
let schemaText = document.getElementById('schema-input');
schemaText.value = '[]';
schemaText.addEventListener('input', () => { schemaDirty = true; });
let schemaDirty = false;
const SCHEMANAME = 'schema.json';
// NEEDS CHANGE: Should use fileRead function for consistency. Should not throw - return default schema object if all loads fail.
async function schemaLoad() {
  log(`‚ÜòÔ∏èschemaLoad`);
  try {
    const file = await fileRead(SCHEMANAME);
    const content = await file.text();
    log(`üìÑ Loaded ${SCHEMANAME}`);
    return content;
  } 
  catch (e) {
    log(`‚ùå schemaLoad: `, e.message);
    return '[]';
  }
}
async function schemaLoadButton() {
  log(`‚ÜòÔ∏èschemaLoadButton`);
  try {schemaText.value=await schemaLoad();schemaDirty=false;}
  catch(e) {log(e.message);}
}
async function schemaSave() {
  log(`‚ÜòÔ∏èschemaSave`);
  await fileCreate(SCHEMANAME, schemaText.value, true);
  log(`üíæ Schema saved to ${SCHEMANAME}`);
}
async function schemaSaveButton() {
  log(`‚ÜòÔ∏èschemaSaveButton`);
  try {await schemaSave(); schemaDirty=false;}
  catch(e) {log(`‚ùå schemaSaveButton: `, e.message);}
}
function schemaMergeOptions(fieldoptions1, fieldoptions2) {
  log(`‚ÜòÔ∏èschemaMergeOptions`);
  const allOptions = [
    ...(fieldoptions1 || []),
    ...(fieldoptions2 || [])
  ];
  const uniqueOptions = allOptions.filter((option, index, self) => self.indexOf(option) === index);
  return uniqueOptions;
}
const schemaHierarchy = { "single": 1, "multiple": 2, "text": 3 };
function schemaFieldUpgrade(currentType, newType) {
  return schemaHierarchy[newType] > schemaHierarchy[currentType] ? newType : currentType;
}
//analyzeFieldPattern has a hidden fragility - it accidentally works because of array-to-string coercion.
function analyzeFieldPattern(collection) {
  log(`‚ÜòÔ∏èanalyzeFieldPattern`);
  const items = collection.filter(Boolean);
  if (!items.length) {
    return { type: 'single', options: [] };
  }
  let hasText = false;
  let hasMultiple = false;
  const tokens = new Set();
  items.forEach(item => {
    const segments = item.split(',');
    const exceedsThreshold = segments.some(segment => segment.length > 26);
    if (exceedsThreshold) {
      hasText = true;
      tokens.add(item);
    } else if (segments.length > 1) {
      hasMultiple = true;
      segments.forEach(segment => tokens.add(segment));
    } else {
      tokens.add(item);
    }
  });
  const fieldType = 
    hasText ? 'text' : 
    hasMultiple ? 'multiple' : 
    'single';
  const result = { type: fieldType };
  if (fieldType !== 'text') {
    result.options = [...tokens];
  }
  return result;
}
function schemaAnalyze(filenames) {
  log(`‚ÜòÔ∏èschemaAnalyze`);
  let inventoryFake = {};
  const imageFiles = filenames.filter(f => /\.(jpg|jpeg|png|gif)$/i.test(f));
  for (const filename of imageFiles) {
    const entry = inventoryFromFile(filename);
    if (entry) inventoryFake = { ...inventoryFake, ...entry };
  }
  const allItems = Object.values(inventoryFake);
  if (!allItems.length) return [];
  const allParsedValues = allItems.map(item => {
    return valuesStringToArray(item.values, null);
  });
  const maxFields = Math.max(...allParsedValues.map(v => v.length));
  const fieldCollections = Array.from({ length: maxFields }, () => []);
  allParsedValues.forEach(parsedArray => {
    parsedArray.forEach((fieldArray, fieldIndex) => {
      if (fieldArray.length > 0) fieldCollections[fieldIndex].push(...fieldArray);
    });
  });
  return fieldCollections.map((collection, index) => {
    const pattern = analyzeFieldPattern(collection);
    return {
      name: `field${index}`,
      type: pattern.type,
      ...(pattern.type !== 'text' && { options: pattern.options })
    };
  });
}
function schemaFuse(schema1, schema2) {
  log(`‚ÜòÔ∏èschemaFuse`);
  if (!Array.isArray(schema1)) schema1 = [];
  if (!Array.isArray(schema2)) schema2 = [];
  const result = [];
  const maxLength = Math.max(schema1.length, schema2.length);
  for (let i = 0; i < maxLength; i++) {
    const field1 = schema1[i];
    const field2 = schema2[i];
    if (field1 && field2) {
      const mergedOptions = schemaMergeOptions(field1.options, field2.options);
      const finalType = schemaFieldUpgrade(field1.type, field2.type);
      result[i] = {
        name: field1.name || field2.name,
        type: finalType,
        ...(mergedOptions && { options: mergedOptions })
      };
    } else if (field1) {
      result[i] = { ...field1 };
    } else if (field2) {
      result[i] = { ...field2 };
    }
  }
  return result;
}
async function schemaLearn() {
  log(`‚ÜòÔ∏èschemaLearn`);
  const fileList = await directoryList();
  if (fileList.length === 0) {
    log('‚ÑπÔ∏è No files found for learning');
    return;
  }
  log(`üß† Learning from ${fileList.length} files...`);
  const learnedSchema = schemaAnalyze(fileList);
  const currentSchema = schemaFromText(schemaText.value);
  const fusedSchema = schemaFuse(currentSchema, learnedSchema);
  schemaText.value = schemaToText(fusedSchema);
  schemaDirty = true;
  log('üéì Schema learning complete');
}
async function schemaLearnButton() {
  log(`‚ÜòÔ∏èschemaLearnButton`);
  try {await schemaLearn(); schemaDirty=true;}
  catch(e) {log(`‚ùå schemaLearnButton`, e.message);}
}
async function schemaInit() {
  log(`‚ÜòÔ∏èschemaInit`);
  schemaText.value = await schemaLoad();
  schemaDirty = false;
  await schemaLearn();
}
function schemaFromText(text) {
  log(`‚ÜòÔ∏èschemaFromText`);
  try {
    if (text == null) throw new Error(`Bit nothin`);
    const parsed = JSON.parse(text);
    return Array.isArray(parsed) ? parsed : [];
  } 
  catch (e) {
    log(`‚ùå schemaFromText:`, ...arguments, e.message);
    return [];
  }
}
function schemaToText(schema) {
  log(`‚ÜòÔ∏èschemaToText `);
  try {
    if (schema == null) throw new Error(`Bit nothin`);
    return JSON.stringify(schema, null, 2);
  } 
  catch (e) {
    log("‚ùå schemaToText: ", e.message);
    return '';
  }
}
function schemaGet() {
  log(`‚ÜòÔ∏èschemaGet`);
  return schemaFromText(schemaText.value);
}
/***** GALLERY *****/
const CACHENAME = 'cache.json';
async function galleryLoad() {
  log(`‚ÜòÔ∏ègalleryLoad`);
  try {
    const gallery = document.getElementById('g-grid');
    gallery.innerHTML = '';
    await cacheLoad();
    for (const uuid in inventory) {
      await new Promise(resolve => requestAnimationFrame(resolve));
      if (uiArray[uiIndex] !== 'mode-gallery') return;
      const thumbnailDataURL = await galleryThumbnailGet(uuid);
      if (thumbnailDataURL) {
        const galleryImg = galleryImageElementCreate(uuid, thumbnailDataURL);
        gallery.appendChild(galleryImg);
      }
    }
    await cacheSave();
  } 
  catch (e) {
    log(`‚ùå galleryLoad: `, e.message);
  }
}
// prevent single image failure from breaking entire gallery
async function cacheLoad() {
  log(`‚ÜòÔ∏ècacheLoad`);
  try {
    const cacheFile = await fileRead(CACHENAME);
    const cacheText = await cacheFile.text();
    const cacheData = JSON.parse(cacheText);
    for (const uuid in cacheData) {
      if (inventory[uuid]) {
        inventory[uuid].thumbnail = cacheData[uuid].thumbnail;
      }
    }
    return cacheData;
  } 
  catch (e) {
    log(`‚ùå cacheLoad:`, e.message);
    return {};
  }
}
async function cacheSave() {
  log(`‚ÜòÔ∏ècacheSave`);
  try {
    const cacheData = {};
    for (const uuid in inventory) {
      if (inventory[uuid].thumbnail) {
        cacheData[uuid] = {
          thumbnail: inventory[uuid].thumbnail
        };
      }
    }
    const cacheJSON = JSON.stringify(cacheData);
    const blob = new Blob([cacheJSON], {type: 'application/json' });
    await fileCreate(CACHENAME, blob, true);
  } 
  catch (e) {
    log(`‚ùå cacheSave:`, e.message);
  }
}
// no error handling, let error fly
async function galleryThumbnailGet(uuid) {
  log(`‚ÜòÔ∏ègalleryThumbnailGet: ${uuid}`);
  if (inventory[uuid]?.thumbnail) {
    return inventory[uuid].thumbnail;
  }
  const item = inventory[uuid];
  if (!item) return null;
  const entry = {[uuid]: item};
  const filename = fileFromInventory(entry);
  const file = await fileRead(filename);
  const thumbnailDataURL = await galleryThumbnailCreate(file);
  inventory[uuid].thumbnail = thumbnailDataURL;
  return thumbnailDataURL;
}
async function galleryThumbnailCreate(file) {
  log(`‚ÜòÔ∏ègalleryThumbnailCreate`);
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const img = new Image();
  const imgUrl = URL.createObjectURL(file);
  return new Promise((resolve) => {
    img.onload = () => {
      URL.revokeObjectURL(imgUrl);
      const size = 512;
      canvas.width = size;
      canvas.height = size;
      ctx.drawImage(img, 0, 0, size, size);
      const dataURL = canvas.toDataURL('image/jpeg', 0.8);
      resolve(dataURL);
    };
    img.src = imgUrl;
  });
}
function galleryImageElementCreate(uuid, thumbnailDataURL) {
  log(`‚ÜòÔ∏ègalleryImageElementCreate: ${uuid}`);
  const galleryImg = document.createElement('img');
  galleryImg.src = thumbnailDataURL;
  galleryImg.className = 'gallery-item';
  galleryImg.loading = 'lazy';
  galleryImg.onclick = async () => {
    const item = inventory[uuid];
    if (!item) return;
    const entry = {[uuid]: item};
    const filename = fileFromInventory(entry);
    if (!filename) {
      log(`‚ùå galleryImageElementCreate: ${uuid}`);
      return;
    }
    const file = await fileRead(filename);
    const originalUrl = URL.createObjectURL(file);
    const popup = window.open('', '_blank');
    popup.document.write(`<img src="${originalUrl}" style="max-width:100%;max-height:100%;">`);
  };
  return galleryImg;
}
/***** TABLE SPREADSHEET *****/
const Table = (function() {
  let selectedCellIds = new Set();
  let editingCell = null;
  let longPressTimer = null;
  let longPressStartX = 0;
  let longPressStartY = 0;
  const LONG_PRESS_DURATION_MS = 500;
  const TOUCH_MOVE_CANCEL_THRESHOLD_PX = 10;
  const domHeaderEl = () => document.getElementById('t-header');
  const domBodyEl = () => document.getElementById('t-body');
  function uuidFieldsFromInventory(uuid) {
    const inventoryItem = inventory[uuid];
    if (!inventoryItem) return null;
    const valuesArray = valuesStringToArray(inventoryItem.values, schemaGet());
    const fieldNameToValueMap = {};
    schemaGet().forEach((schemaField, fieldIndex) => {
      fieldNameToValueMap[schemaField.name] = (valuesArray[fieldIndex] || []).join(',');
    });
    return fieldNameToValueMap;
  }
  function inventoryFieldUpdate(uuid, fieldName, newValue) {
    const inventoryItem = inventory[uuid];
    if (!inventoryItem) return;
    const currentSchema = schemaGet();
    const valuesArray = valuesStringToArray(inventoryItem.values, currentSchema);
    const fieldIndex = currentSchema.findIndex(f => f.name === fieldName);
    if (fieldIndex === -1) return;
    if (currentSchema[fieldIndex].type === 'multiple') {
      valuesArray[fieldIndex] = newValue ? newValue.split(',') : [];
    } else {
      valuesArray[fieldIndex] = newValue ? [newValue] : [];
    }
    const updatedValuesString = valuesArrayToString(valuesArray);
    const updatedInventoryEntry = {[uuid]: {...inventoryItem, values: updatedValuesString}};
    inventoryUpdate(updatedInventoryEntry).catch(err => log(`Update failed: ${err.message}`));
  }
  function renderTableFromInventory() {
    log('‚ÜòÔ∏èTable.render');
    const currentSchema = schemaGet();
    const columnCount = currentSchema.length;
    domBodyEl().parentElement.style.setProperty('--cols', columnCount);
    const headerCellsHtml = currentSchema.map(f => `<div class="table-cell">${f.name}</div>`).join('');
    domHeaderEl().innerHTML = '<div class="table-cell">üì∑</div>' + headerCellsHtml;
    const rowsHtml = Object.entries(inventory).map(([uuid, inventoryItem]) => {
      const fieldValues = uuidFieldsFromInventory(uuid);
      if (!fieldValues) return '';
      const thumbnailHtml = inventoryItem.thumbnail 
        ? `<img src="${inventoryItem.thumbnail}" style="width:38px;height:38px;object-fit:cover">`
        : 'üì∑';
      const dataCellsHtml = currentSchema.map(schemaField => 
        `<div class="table-cell" data-uuid="${uuid}" data-field="${schemaField.name}">${fieldValues[schemaField.name] || ''}</div>`
      ).join('');
      return `<div class="table-row"><div class="table-cell" data-uuid="${uuid}" data-thumb="true">${thumbnailHtml}</div>${dataCellsHtml}</div>`;
    }).join('');
    domBodyEl().innerHTML = rowsHtml;
    domBodyEl().addEventListener('click', handleCellClickEvent);
    domBodyEl().addEventListener('touchstart', handleCellTouchStartEvent);
    domBodyEl().addEventListener('touchmove', handleCellTouchMoveEvent);
    domBodyEl().addEventListener('touchend', handleCellTouchEndEvent);
  }
  function handleCellClickEvent(clickEvent) {
    const clickedCell = clickEvent.target.closest('[data-field]');
    if (!clickedCell) return;
    const clickedCellId = buildCellId(clickedCell);
    if (editingCell) finishEditingAndSave();
    if (!selectedCellIds.has(clickedCellId)) clearAllSelections();
    beginEditingCell(clickedCell);
  }
  function handleCellTouchStartEvent(touchEvent) {
    const touchedCell = touchEvent.target.closest('[data-field]');
    if (!touchedCell || editingCell) return;
    longPressStartX = touchEvent.touches[0].clientX;
    longPressStartY = touchEvent.touches[0].clientY;
    longPressTimer = setTimeout(() => {
      toggleCellSelection(touchedCell);
      longPressTimer = null;
    }, LONG_PRESS_DURATION_MS);
  }
  function handleCellTouchMoveEvent(touchEvent) {
    if (!longPressTimer) return;
    const touchMoveDistanceX = Math.abs(touchEvent.touches[0].clientX - longPressStartX);
    const touchMoveDistanceY = Math.abs(touchEvent.touches[0].clientY - longPressStartY);
    if (touchMoveDistanceX > TOUCH_MOVE_CANCEL_THRESHOLD_PX || touchMoveDistanceY > TOUCH_MOVE_CANCEL_THRESHOLD_PX) {
      clearTimeout(longPressTimer);
      longPressTimer = null;
    }
  }
  function handleCellTouchEndEvent(touchEndEvent) {
    if (longPressTimer) {
      clearTimeout(longPressTimer);
      longPressTimer = null;
    }
  }
  function buildCellId(cellElement) {
    return `${cellElement.dataset.uuid}::${cellElement.dataset.field}`;
  }
  function toggleCellSelection(cellElement) {
    const cellId = buildCellId(cellElement);
    if (selectedCellIds.has(cellId)) {
      selectedCellIds.delete(cellId);
      delete cellElement.dataset.state;
    } else {
      selectedCellIds.add(cellId);
      cellElement.dataset.state = 'selected';
    }
  }
  function clearAllSelections() {
    domBodyEl().querySelectorAll('[data-state="selected"]').forEach(selectedCell => {
      delete selectedCell.dataset.state;
    });
    selectedCellIds.clear();
  }
  function beginEditingCell(cellElement) {
    editingCell = cellElement;
    cellElement.dataset.state = 'editing';
    const cellUuid = cellElement.dataset.uuid;
    const cellFieldName = cellElement.dataset.field;
    const currentFieldValues = uuidFieldsFromInventory(cellUuid);
    const currentCellValue = currentFieldValues?.[cellFieldName] || '';
    const editInputElement = document.createElement('input');
    editInputElement.value = currentCellValue;
    cellElement.textContent = '';
    cellElement.appendChild(editInputElement);
    editInputElement.focus();
    editInputElement.select();
    editInputElement.onblur = () => finishEditingAndSave();
    editInputElement.onkeydown = keyEvent => {
      keyEvent.stopPropagation();
      if (keyEvent.key === 'Enter') editInputElement.blur();
      if (keyEvent.key === 'Escape') { 
        editInputElement.value = currentCellValue; 
        editInputElement.blur(); 
      }
    };
  }
  function finishEditingAndSave() {
    if (!editingCell) return;
    const editInputElement = editingCell.querySelector('input');
    const userEnteredValue = editInputElement.value;
    const editedCellUuid = editingCell.dataset.uuid;
    const editedCellFieldName = editingCell.dataset.field;
    const editedCellId = buildCellId(editingCell);
    const cellIdsToUpdate = selectedCellIds.size > 0 ? [...selectedCellIds] : [editedCellId];
    cellIdsToUpdate.forEach(cellIdToUpdate => {
      const [uuidToUpdate, fieldNameToUpdate] = cellIdToUpdate.split('::');
      inventoryFieldUpdate(uuidToUpdate, fieldNameToUpdate, userEnteredValue);
      const cellElementToUpdate = domBodyEl().querySelector(`[data-uuid="${uuidToUpdate}"][data-field="${fieldNameToUpdate}"]`);
      if (cellElementToUpdate) {
        cellElementToUpdate.textContent = userEnteredValue;
        delete cellElementToUpdate.dataset.state;
      }
    });
    clearAllSelections();
    delete editingCell.dataset.state;
    editingCell = null;
  }
  return { init: renderTableFromInventory };
})();
// DISCUSSION: How to make components more robust?
// RESILIENT INPUT + NON-BLOCKING: Wizard failures return empty metadata rather than throwing. Input validation warns but doesn't prevent progression. Build functions handle missing schema gracefully.
/***** WIZARD OVERLAY *****/
const Wizard = (function() {
  let wizardOverlay;
  let wizardPanels;
  let navi;
  let schema;
  let values;
  let step;
  let resolve;
  let reject;
  function gridSizer(buttonCount, aspectRatio) {
    log(`‚ÜòÔ∏èWizard.gridSizer`);
    let bestRows = 1;
    let bestCols = buttonCount;
    let bestSkinny = 0.0;
    for (let rows = 1; rows <= buttonCount; rows++) {
      const cols = Math.ceil(buttonCount / rows);
      const width = aspectRatio / cols;
      const height = 1.0 / rows;
      const nowSkinny = Math.min(width, height);
      if (nowSkinny > bestSkinny) {
        bestSkinny = nowSkinny;
        bestRows = rows;
        bestCols = cols;
      }
    }
    return { rows: bestRows, cols: bestCols };
  }
  function refresh() {
    log(`‚ÜòÔ∏èWizard.refresh`);
    if (step < 0) {
      step = 0;
    } else if (step >= schema.length) {
      done();
      return;
    }
    const screens = Array.from(wizardPanels.children);
    screens.forEach((screen, index) => {
      if (index === step) {
        screen.classList.add('active');
      } else {
        screen.classList.remove('active');
      }
    });
  }
  function init() {
    log(`‚ÜòÔ∏èWizard.init`);
    wizardOverlay = document.getElementById('w-overlay');
    wizardPanels = document.getElementById('w-panels');
    wizardPanels.innerHTML = '';
    navi = document.getElementById('w-navi');
    navi.innerHTML = '';
    [
      {textContent: '‚¨ÖÔ∏è', onclick: back},
      {textContent: '‚ùå', onclick: kill},
      {textContent: 'üíæ', onclick: done},
      {textContent: '‚û°Ô∏è', onclick: next}
    ].forEach(config => {
      const button = document.createElement('button');
      Object.assign(button, config, { className: 'nav-button' });
      navi.appendChild(button);
    });
  }
  function build() {
    log(`‚ÜòÔ∏èWizard.build`);
    schema.forEach((_, index) => {
      const screen = document.createElement('div');
      screen.className = 'wizard-screen';
      buildScreenContent(screen, index);
      wizardPanels.appendChild(screen);
    });
  }
  // CHANGE?
  function buildScreenContent(screen, index) {
    log(`‚ÜòÔ∏èWizard.buildScreenContent`);
    const field = schema[index];
    if (field.type === 'text') {
      screen.style.cssText = 'grid-template-columns:1fr;grid-template-rows:1fr';
      const textarea = document.createElement('textarea');
      textarea.className = 'wizard-input-text';
      textarea.placeholder = `Enter ${field.name}`;
      textarea.value = values[index] ? values[index].join(',') : '';
      textarea.oninput = () => {
        values[index] = [textarea.value];
      };
      screen.appendChild(textarea);
    } else {
      const availableHeight = window.innerHeight - 80;
      const availableWidth = window.innerWidth;
      const grid = gridSizer(field.options.length, availableWidth / availableHeight);
      screen.style.cssText = `grid-template-columns:repeat(${grid.cols},1fr);grid-template-rows:repeat(${grid.rows},1fr)`;
      field.options.forEach((option, optionIndex) => {
        const input = document.createElement('input');
        input.value = option;
        input.className = 'wizard-input';
        input.name = `field-${index}`;
        const id = `field-${index}-${field.name}-${optionIndex}`;
        input.id = id;
        if (field.type === 'multiple') {
          input.type = 'checkbox';
          //if (values[index] && values[index].includes(option)) {input.checked = true;}
          input.onchange = () => {
            const checkedInputs = screen.querySelectorAll('input[type="checkbox"]:checked');
            values[index] = Array.from(checkedInputs).map(inp => inp.value);
          };
        } else if (field.type === 'single') {
          input.type = 'radio';
          //if (values[index] && values[index][0] === option) {input.checked = true;}
          input.onchange = () => {
            values[index] = [option];
            next();
          };
        }
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'wizard-label';
        button.textContent = option;
        button.onclick = () => {
          input.checked = !input.checked;
          input.onchange();
        };
        screen.appendChild(input);
        screen.appendChild(button);
      });
    }
  }
//  AI OMITTED THIS FUNCTION DURING METADATA AND INVENTORY BLUEPRPINT ARCHITECTURE REFACTOR
//  function mergeMetadata(metadata1, metadata2) {
//    log(`‚ÜòÔ∏èmergeMetadata`);
//    const mergedResult = { ...metadata1 , ...metadata2 };
//    mergedResult.data = {...metadata1.data, ...metadata2.data};
//    const isEmptyArray = x => Array.isArray(x) && x.length === 0;
//    const maxLength = Math.max(metadata1.values?.length ?? 0, metadata2.values?.length ?? 0)
//    mergedResult.values = Array.from({ length: maxLength }, (_, i) =>
//      isEmptyArray(metadata2?.values[i]||[]) ?
//        (isEmptyArray(metadata1?.values[i]||[]) ?
//          []
//          :
//         metadata1.values[i])
//        :
//        metadata2.values[i]
//    );
//    return mergedResult;
//  }
  function record() {
    log(`‚ÜòÔ∏èWizard.record`);
    values = [];
    step = 0;
    schema = schemaGet();
    init();
    build();
    wizardOverlay.style.display = 'flex';
    return new Promise((res, rej) => {
      resolve = res;
      reject = rej;
      refresh();
    });
  }
  // DISCUSSION: If the wizard fails for some reason, should it return an empty metadata? Should the calling function save the image with empty metadata?
  function kill() {
    log(`‚ÜòÔ∏èWizard.kill`);
    wizardOverlay.style.display = 'none';
    if (reject) {
      reject(new Error('WIZARD_KILLED'));
    }
  }
  function done() {
    log(`‚ÜòÔ∏èWizard.done`);
    wizardOverlay.style.display = 'none';
    if (resolve) {
      const rawString = valuesArrayToString(values);
      resolve(rawString);
    }
  }
  function back() {
    log(`‚ÜòÔ∏èWizard.back`);
    step--;
    refresh();
  }
  function next() {
    log(`‚ÜòÔ∏èWizard.next`);
    step++;
    refresh();
  }
  return { record, kill, done, back, next };
})();
log('script end');
  </script>
</body>
</html>
